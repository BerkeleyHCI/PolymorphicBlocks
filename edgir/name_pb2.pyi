"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
File : name.proto
Package : edg.name

There are three major classes of name in edg:
- Namespaces, which help organize elements within libraries.
- LocalNames, which help organize elements relative to each other.
- LibraryNames, which we use to identify specific libraries.
"""
import builtins
from .. import edgir
import google.protobuf.descriptor
import google.protobuf.message
import sys
if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class Namespace(google.protobuf.message.Message):
    """*
    A namespace allows us to define a more useful organizational structure
    over items in the library. It lets us group elements in categories that
    are orthogonal to the usual Block, Port, Link, ontology.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    BASIC_FIELD_NUMBER: builtins.int
    META_FIELD_NUMBER: builtins.int
    basic: builtins.str
    "* Basic namespaces are a way to organize library elements into a\n    useful hirearchy (e.g. 'Core.*' for the most primitive definitions\n    that we define, or 'NXP.*' for NXP made components.)\n\n    Basic namespaces should have the following properties:\n\n    - First char is a capital letter\n    - All other chars must be letters, numbers, '-', '<', '>'\n    - CamelCase is preffered, don't use any symbols in the name\n    if possible.\n    "

    @property
    def meta(self) -> edgir.common_pb2.Metadata:
        ...

    def __init__(self, *, basic: builtins.str=..., meta: edgir.common_pb2.Metadata | None=...) -> None:
        ...

    def HasField(self, field_name: typing_extensions.Literal['basic', b'basic', 'meta', b'meta', 'namespace', b'namespace']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing_extensions.Literal['basic', b'basic', 'meta', b'meta', 'namespace', b'namespace']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing_extensions.Literal['namespace', b'namespace']) -> typing_extensions.Literal['basic'] | None:
        ...
global___Namespace = Namespace

@typing_extensions.final
class LibraryName(google.protobuf.message.Message):
    """* A library name is a way to identify a specific library from a
    set of parent libraries.

    This can be the initial element in a path or reference.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    META_FIELD_NUMBER: builtins.int
    name: builtins.str
    "* Since libraries allow for inheritance, we will often want to say\n    this element, defined in *this* particular library.\n\n    In those cases we want to be able to specify the relevant library\n    by its identifier.\n\n    Otherwise we assume it's somehow implicit which library we're\n    talking about.\n    "

    @property
    def meta(self) -> edgir.common_pb2.Metadata:
        ...

    def __init__(self, *, name: builtins.str=..., meta: edgir.common_pb2.Metadata | None=...) -> None:
        ...

    def HasField(self, field_name: typing_extensions.Literal['meta', b'meta']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing_extensions.Literal['meta', b'meta', 'name', b'name']) -> None:
        ...
global___LibraryName = LibraryName