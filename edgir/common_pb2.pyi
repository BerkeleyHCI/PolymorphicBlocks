"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

#* Arbitrary metadata stored in tree form.
class Metadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Members(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class NodeEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            @property
            def value(self) -> global___Metadata: ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Optional[global___Metadata] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal[u"value",b"value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

        NODE_FIELD_NUMBER: builtins.int
        @property
        def node(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___Metadata]: ...
        def __init__(self,
            *,
            node : typing.Optional[typing.Mapping[typing.Text, global___Metadata]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"node",b"node"]) -> None: ...

    UNKNOWN_FIELD_NUMBER: builtins.int
    KNOWN_FIELD_NUMBER: builtins.int
    MEMBERS_FIELD_NUMBER: builtins.int
    TEXT_LEAF_FIELD_NUMBER: builtins.int
    BIN_LEAF_FIELD_NUMBER: builtins.int
    SOURCE_LOCATOR_FIELD_NUMBER: builtins.int
    NAMESPACE_ORDER_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    COPPER_NET_FIELD_NUMBER: builtins.int
    FOOTPRINT_FIELD_NUMBER: builtins.int
    @property
    def unknown(self) -> global___Empty: ...
    known: typing.Text = ...
    @property
    def members(self) -> global___Metadata.Members: ...
    text_leaf: typing.Text = ...
    #* I wanted to split binary and text data, since we might
    #just want to dump a raw file/image/datasheet in here
    #for safekeeping.
    #
    #Mixing up binary and textual formats is just a recipe
    #for trouble.
    bin_leaf: builtins.bytes = ...
    # Defined formats
    # Note: key should be the message definition name (eg, SourceLocator)
    # TODO: how to handle multiple metadata of a given type?
    @property
    def source_locator(self) -> global___SourceLocator: ...
    @property
    def namespace_order(self) -> global___NamespaceOrder: ...
    @property
    def error(self) -> global___Error: ...
    # Electronics-specific formats
    @property
    def copper_net(self) -> global___CopperNet: ...
    @property
    def footprint(self) -> global___Footprint: ...
    def __init__(self,
        *,
        unknown : typing.Optional[global___Empty] = ...,
        known : typing.Text = ...,
        members : typing.Optional[global___Metadata.Members] = ...,
        text_leaf : typing.Text = ...,
        bin_leaf : builtins.bytes = ...,
        source_locator : typing.Optional[global___SourceLocator] = ...,
        namespace_order : typing.Optional[global___NamespaceOrder] = ...,
        error : typing.Optional[global___Error] = ...,
        copper_net : typing.Optional[global___CopperNet] = ...,
        footprint : typing.Optional[global___Footprint] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"bin_leaf",b"bin_leaf",u"copper_net",b"copper_net",u"error",b"error",u"footprint",b"footprint",u"known",b"known",u"members",b"members",u"meta",b"meta",u"namespace_order",b"namespace_order",u"source_locator",b"source_locator",u"text_leaf",b"text_leaf",u"type",b"type",u"unknown",b"unknown"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"bin_leaf",b"bin_leaf",u"copper_net",b"copper_net",u"error",b"error",u"footprint",b"footprint",u"known",b"known",u"members",b"members",u"meta",b"meta",u"namespace_order",b"namespace_order",u"source_locator",b"source_locator",u"text_leaf",b"text_leaf",u"type",b"type",u"unknown",b"unknown"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"meta",b"meta"]) -> typing.Optional[typing_extensions.Literal["members","text_leaf","bin_leaf","source_locator","namespace_order","error","copper_net","footprint"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"type",b"type"]) -> typing.Optional[typing_extensions.Literal["unknown","known"]]: ...
global___Metadata = Metadata

#* Definitions for structured metadata formats

#* For locating source data
class SourceLocator(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SourceType(_SourceType, metaclass=_SourceTypeEnumTypeWrapper):
        pass
    class _SourceType:
        V = typing.NewType('V', builtins.int)
    class _SourceTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SourceType.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNKNOWN = SourceLocator.SourceType.V(0)
        # source defining this class, would be present in library
        DEFINITION = SourceLocator.SourceType.V(1)
        # source of instantiation, would be present in design
        INSTANTIATION = SourceLocator.SourceType.V(2)

    UNKNOWN = SourceLocator.SourceType.V(0)
    # source defining this class, would be present in library
    DEFINITION = SourceLocator.SourceType.V(1)
    # source of instantiation, would be present in design
    INSTANTIATION = SourceLocator.SourceType.V(2)

    FILE_PACKAGE_FIELD_NUMBER: builtins.int
    LINE_OFFSET_FIELD_NUMBER: builtins.int
    COL_OFFSET_FIELD_NUMBER: builtins.int
    SOURCE_TYPE_FIELD_NUMBER: builtins.int
    # package name (portable, not tied to an absolute path) that locates the file
    file_package: typing.Text = ...
    # line number
    line_offset: builtins.int = ...
    # character offset within the line
    col_offset: builtins.int = ...
    source_type: global___SourceLocator.SourceType.V = ...
    def __init__(self,
        *,
        file_package : typing.Text = ...,
        line_offset : builtins.int = ...,
        col_offset : builtins.int = ...,
        source_type : global___SourceLocator.SourceType.V = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"col_offset",b"col_offset",u"file_package",b"file_package",u"line_offset",b"line_offset",u"source_type",b"source_type"]) -> None: ...
global___SourceLocator = SourceLocator

#* Supplemental data structure for anything containing a namespace (eg, Block, Link) that
#defines the original lexical ordering (since proto maps are not order-preserving)
class NamespaceOrder(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAMES_FIELD_NUMBER: builtins.int
    # names in order, lowest index is first
    @property
    def names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    def __init__(self,
        *,
        names : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"names",b"names"]) -> None: ...
global___NamespaceOrder = NamespaceOrder

#* Used to communicate results of analysis / checking passes.
#Limited to Block and Link objects.
class Error(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MESSAGE_FIELD_NUMBER: builtins.int
    TRACEBACK_FIELD_NUMBER: builtins.int
    SOURCE_FIELD_NUMBER: builtins.int
    # free-form error message
    message: typing.Text = ...
    # full traceback  TODO: should there be a structured stack trace?
    traceback: typing.Text = ...
    # source locator, eg line of failing constraint
    @property
    def source(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SourceLocator]: ...
    def __init__(self,
        *,
        message : typing.Text = ...,
        traceback : typing.Text = ...,
        source : typing.Optional[typing.Iterable[global___SourceLocator]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"message",b"message",u"source",b"source",u"traceback",b"traceback"]) -> None: ...
global___Error = Error

#* Indicates a copper connection between ports
# Currently empty (all-to-all copper connection implied)
# TODO: future feature: define specific ports connected?
class CopperNet(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___CopperNet = CopperNet

#* Defines a footprint with copper mapping between pins and own ports
class Footprint(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class PinningEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    REFDES_PREFIX_FIELD_NUMBER: builtins.int
    FOOTPRINT_NAME_FIELD_NUMBER: builtins.int
    PINNING_FIELD_NUMBER: builtins.int
    PART_FIELD_NUMBER: builtins.int
    MANUFACTURER_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    # eg, 'U' for chips, 'R' for resistors
    refdes_prefix: typing.Text = ...
    # footprint name in KiCad format, including library
    footprint_name: typing.Text = ...
    # footprint pin -> port name (which can use dots to indicate path sub-components)
    @property
    def pinning(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]: ...
    # TODO: use Ref.LocalPath? but importing ref creates a circular import dependency

    # part number
    part: typing.Text = ...
    manufacturer: typing.Text = ...
    # only for informational purposes when inspecting components in layout
    value: typing.Text = ...
    def __init__(self,
        *,
        refdes_prefix : typing.Text = ...,
        footprint_name : typing.Text = ...,
        pinning : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        part : typing.Text = ...,
        manufacturer : typing.Text = ...,
        value : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"footprint_name",b"footprint_name",u"manufacturer",b"manufacturer",u"part",b"part",u"pinning",b"pinning",u"refdes_prefix",b"refdes_prefix",u"value",b"value"]) -> None: ...
global___Footprint = Footprint

#* Placeholder until I figure out how to import properly
class Empty(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___Empty = Empty
