"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import edgir.common_pb2
import edgir.lit_pb2
import edgir.ref_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class UnaryExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Op:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[UnaryExpr._Op.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNDEFINED: UnaryExpr._Op.ValueType  # 0
        NEGATE: UnaryExpr._Op.ValueType  # 1
        """* Negate :: Numeric a =>       a -> a
        :: Numeric a => Range a -> Range a
        """

        NOT: UnaryExpr._Op.ValueType  # 2
        """* Not :: Bool -> Bool"""

        INVERT: UnaryExpr._Op.ValueType  # 3
        """* Invert ::       Float -> Float
        :: Range Float -> Range Float
        """

        MIN: UnaryExpr._Op.ValueType  # 4
        """* Min :: Range a -> a"""

        MAX: UnaryExpr._Op.ValueType  # 5
        """* Max :: Range a -> a"""

        CENTER: UnaryExpr._Op.ValueType  # 6
        """* Center :: Range a -> a"""

        WIDTH: UnaryExpr._Op.ValueType  # 7
        """* Width :: Range a -> a"""

    class Op(_Op, metaclass=_OpEnumTypeWrapper):
        pass

    UNDEFINED: UnaryExpr.Op.ValueType  # 0
    NEGATE: UnaryExpr.Op.ValueType  # 1
    """* Negate :: Numeric a =>       a -> a
    :: Numeric a => Range a -> Range a
    """

    NOT: UnaryExpr.Op.ValueType  # 2
    """* Not :: Bool -> Bool"""

    INVERT: UnaryExpr.Op.ValueType  # 3
    """* Invert ::       Float -> Float
    :: Range Float -> Range Float
    """

    MIN: UnaryExpr.Op.ValueType  # 4
    """* Min :: Range a -> a"""

    MAX: UnaryExpr.Op.ValueType  # 5
    """* Max :: Range a -> a"""

    CENTER: UnaryExpr.Op.ValueType  # 6
    """* Center :: Range a -> a"""

    WIDTH: UnaryExpr.Op.ValueType  # 7
    """* Width :: Range a -> a"""


    OP_FIELD_NUMBER: builtins.int
    VAL_FIELD_NUMBER: builtins.int
    op: global___UnaryExpr.Op.ValueType
    @property
    def val(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        op: global___UnaryExpr.Op.ValueType = ...,
        val: typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["val",b"val"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["op",b"op","val",b"val"]) -> None: ...
global___UnaryExpr = UnaryExpr

class UnarySetExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Op:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[UnarySetExpr._Op.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNDEFINED: UnarySetExpr._Op.ValueType  # 0
        SUM: UnarySetExpr._Op.ValueType  # 1
        """* Sum :: (Numeric a) => Set a -> a
        :: (Numeric a) => Set (Range a) -> Range a

        Sum({}) = 0
        """

        ALL_TRUE: UnarySetExpr._Op.ValueType  # 2
        """* All :: Set Bool -> Bool

        All inputs are true
        All({}) = True
        """

        ANY_TRUE: UnarySetExpr._Op.ValueType  # 3
        """* Any :: Set Bool -> Bool

        Any of the inputs are true
        Any({}) = False
        """

        ALL_EQ: UnarySetExpr._Op.ValueType  # 4
        """* AllEq :: (Equality a) => Set a -> Bool

        AllEq({}) = True
        """

        ALL_UNIQUE: UnarySetExpr._Op.ValueType  # 5
        """* AllUnique :: (Equality a) => Set a -> Bool

        AllUnique(EmptySet) = True
        """

        MAXIMUM: UnarySetExpr._Op.ValueType  # 10
        """* Size :: Set a -> Integer

        SIZE = 6;

        * Maximum :: (Ordered a) => Set a -> a

        This op requires that the non-emptyness of the relevant set is assured
        before being valid.
        """

        MINIMUM: UnarySetExpr._Op.ValueType  # 11
        """* Minimum :: (Ordered a) => Set a -> a

        This op requires that the non-emptyness of the relevant set is assured
        before being valid.
        """

        SET_EXTRACT: UnarySetExpr._Op.ValueType  # 12
        """* SetExtract :: Set a -> a

        This op requires that the non-emptyness of the relevant set is assured
        before being valid. In addition this assumes all values in the set are equal.
        """

        INTERSECTION: UnarySetExpr._Op.ValueType  # 13
        """* Intersection :: Set (Range a) -> Range a

        May produce an empty range.
        Intersection({}) = [-inf, +inf]
        """

        HULL: UnarySetExpr._Op.ValueType  # 14
        """* Hull :: Set (Range a) -> Range a
        Returns the convex hull (union with all the inner missing bits filled in)
        Hull({}) = EmptyRange
        """

        NEGATE: UnarySetExpr._Op.ValueType  # 20
        """* Negate :: Numeric a => Set a         -> Set a
        :: Numeric a => Set (Range a) -> Set (Range a)

        Pointwise negate
        """

        INVERT: UnarySetExpr._Op.ValueType  # 21
        """* Invert :: Set Float         -> Set Float
        :: Set (Range Float) -> Set (Range Float)

        Pointwise Invert
        """

    class Op(_Op, metaclass=_OpEnumTypeWrapper):
        pass

    UNDEFINED: UnarySetExpr.Op.ValueType  # 0
    SUM: UnarySetExpr.Op.ValueType  # 1
    """* Sum :: (Numeric a) => Set a -> a
    :: (Numeric a) => Set (Range a) -> Range a

    Sum({}) = 0
    """

    ALL_TRUE: UnarySetExpr.Op.ValueType  # 2
    """* All :: Set Bool -> Bool

    All inputs are true
    All({}) = True
    """

    ANY_TRUE: UnarySetExpr.Op.ValueType  # 3
    """* Any :: Set Bool -> Bool

    Any of the inputs are true
    Any({}) = False
    """

    ALL_EQ: UnarySetExpr.Op.ValueType  # 4
    """* AllEq :: (Equality a) => Set a -> Bool

    AllEq({}) = True
    """

    ALL_UNIQUE: UnarySetExpr.Op.ValueType  # 5
    """* AllUnique :: (Equality a) => Set a -> Bool

    AllUnique(EmptySet) = True
    """

    MAXIMUM: UnarySetExpr.Op.ValueType  # 10
    """* Size :: Set a -> Integer

    SIZE = 6;

    * Maximum :: (Ordered a) => Set a -> a

    This op requires that the non-emptyness of the relevant set is assured
    before being valid.
    """

    MINIMUM: UnarySetExpr.Op.ValueType  # 11
    """* Minimum :: (Ordered a) => Set a -> a

    This op requires that the non-emptyness of the relevant set is assured
    before being valid.
    """

    SET_EXTRACT: UnarySetExpr.Op.ValueType  # 12
    """* SetExtract :: Set a -> a

    This op requires that the non-emptyness of the relevant set is assured
    before being valid. In addition this assumes all values in the set are equal.
    """

    INTERSECTION: UnarySetExpr.Op.ValueType  # 13
    """* Intersection :: Set (Range a) -> Range a

    May produce an empty range.
    Intersection({}) = [-inf, +inf]
    """

    HULL: UnarySetExpr.Op.ValueType  # 14
    """* Hull :: Set (Range a) -> Range a
    Returns the convex hull (union with all the inner missing bits filled in)
    Hull({}) = EmptyRange
    """

    NEGATE: UnarySetExpr.Op.ValueType  # 20
    """* Negate :: Numeric a => Set a         -> Set a
    :: Numeric a => Set (Range a) -> Set (Range a)

    Pointwise negate
    """

    INVERT: UnarySetExpr.Op.ValueType  # 21
    """* Invert :: Set Float         -> Set Float
    :: Set (Range Float) -> Set (Range Float)

    Pointwise Invert
    """


    OP_FIELD_NUMBER: builtins.int
    VALS_FIELD_NUMBER: builtins.int
    op: global___UnarySetExpr.Op.ValueType
    @property
    def vals(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        op: global___UnarySetExpr.Op.ValueType = ...,
        vals: typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["vals",b"vals"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["op",b"op","vals",b"vals"]) -> None: ...
global___UnarySetExpr = UnarySetExpr

class BinaryExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Op:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[BinaryExpr._Op.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNDEFINED: BinaryExpr._Op.ValueType  # 0
        ADD: BinaryExpr._Op.ValueType  # 10
        """* Add :: Numeric a => (lhs ::       a, rhs ::       a) -> a
        :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a
        """

        MULT: BinaryExpr._Op.ValueType  # 12
        """* Sub :: Numeric a => (lhs ::       a, rhs ::       a) -> a
        :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a

        SUB = 11; // Use ADD and NEGATE instead

        * Mult :: Numeric a => (lhs ::       a, rhs ::       a) -> a
        :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a
        """

        AND: BinaryExpr._Op.ValueType  # 20
        """* Div :: Numeric a => (lhs ::       a, rhs ::       a) -> a
        :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a

        DIV = 13; // Use MULT and INVERT instead

        * And :: (lhs :: Bool, rhs :: Bool) -> Bool
        """

        OR: BinaryExpr._Op.ValueType  # 21
        """* Or :: (lhs :: Bool, rhs :: Bool) -> Bool"""

        XOR: BinaryExpr._Op.ValueType  # 22
        """* Xor :: (lhs :: Bool, rhs :: Bool) -> Bool"""

        IMPLIES: BinaryExpr._Op.ValueType  # 23
        """* Implies :: (lhs :: Bool, rhs :: Bool) -> Bool"""

        EQ: BinaryExpr._Op.ValueType  # 30
        """* Iff :: (lhs :: Bool, rhs :: Bool) -> Bool

        IFF = 24; // Use EQ instead

        * Eq :: (Equality a) =>  (lhs :: a, rhs :: a)  -> Bool
        """

        NEQ: BinaryExpr._Op.ValueType  # 31
        """* Neq :: (Equality a) => (lhs :: a, rhs : a)  -> Bool"""

        GT: BinaryExpr._Op.ValueType  # 40
        """* GT :: (Comparable a) =>  (lhs :: a, rhs :: a)  -> Bool"""

        GTE: BinaryExpr._Op.ValueType  # 41
        """* GTE :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool"""

        LT: BinaryExpr._Op.ValueType  # 42
        """* LT :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool"""

        LTE: BinaryExpr._Op.ValueType  # 44
        """* LTE :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool"""

        MAX: BinaryExpr._Op.ValueType  # 45
        """* Max :: (Comparable a) => (lhs :: a, rhs :: a)  -> a"""

        MIN: BinaryExpr._Op.ValueType  # 46
        """* Min :: (Comparable a) =>  (lhs :: a, rhs :: a)  -> a"""

        INTERSECTION: BinaryExpr._Op.ValueType  # 51
        """* Union :: (Set_Like s, Equality a) => (lhs :: s a, rhs :: s a) -> Set a

        Note how, no matter the type of setlike thing we use as
        input, the output is alwys an unordered set.

        UNION = 50;

        * Intersection :: (Numeric a) => (lhs : Range a, rhs : Range a) -> Range a
        """

        HULL: BinaryExpr._Op.ValueType  # 54
        """* Hull :: (lhs :: Range a, rhs :: Range a) -> Range a
        Given two input ranges, returns the convex hull (union with
        all the inner missing bits filled in)
        """

        WITHIN: BinaryExpr._Op.ValueType  # 53
        """* Intersects :: (Set_Like s, Equality a) => (lhs :: s a, rhs :: s a) -> Bool

        INTERSECTS = 52;

        * Within :: (Numeric a) => (lhs :: Range a, rhs :: Range a) -> Bool
        :: (Numeric a) => (lhs ::       a, rhs :: Range a) -> Bool

        Whether the lhs range or point is entirely within (contained by) the rhs.
        Used to be named SUBSET changed to a name that doesn't also imply a set op.
        """

        RANGE: BinaryExpr._Op.ValueType  # 1
        """* Range :: (Comparable a) => (lower :: a, upper :: a) -> Range a"""

    class Op(_Op, metaclass=_OpEnumTypeWrapper):
        pass

    UNDEFINED: BinaryExpr.Op.ValueType  # 0
    ADD: BinaryExpr.Op.ValueType  # 10
    """* Add :: Numeric a => (lhs ::       a, rhs ::       a) -> a
    :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a
    """

    MULT: BinaryExpr.Op.ValueType  # 12
    """* Sub :: Numeric a => (lhs ::       a, rhs ::       a) -> a
    :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a

    SUB = 11; // Use ADD and NEGATE instead

    * Mult :: Numeric a => (lhs ::       a, rhs ::       a) -> a
    :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a
    """

    AND: BinaryExpr.Op.ValueType  # 20
    """* Div :: Numeric a => (lhs ::       a, rhs ::       a) -> a
    :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a

    DIV = 13; // Use MULT and INVERT instead

    * And :: (lhs :: Bool, rhs :: Bool) -> Bool
    """

    OR: BinaryExpr.Op.ValueType  # 21
    """* Or :: (lhs :: Bool, rhs :: Bool) -> Bool"""

    XOR: BinaryExpr.Op.ValueType  # 22
    """* Xor :: (lhs :: Bool, rhs :: Bool) -> Bool"""

    IMPLIES: BinaryExpr.Op.ValueType  # 23
    """* Implies :: (lhs :: Bool, rhs :: Bool) -> Bool"""

    EQ: BinaryExpr.Op.ValueType  # 30
    """* Iff :: (lhs :: Bool, rhs :: Bool) -> Bool

    IFF = 24; // Use EQ instead

    * Eq :: (Equality a) =>  (lhs :: a, rhs :: a)  -> Bool
    """

    NEQ: BinaryExpr.Op.ValueType  # 31
    """* Neq :: (Equality a) => (lhs :: a, rhs : a)  -> Bool"""

    GT: BinaryExpr.Op.ValueType  # 40
    """* GT :: (Comparable a) =>  (lhs :: a, rhs :: a)  -> Bool"""

    GTE: BinaryExpr.Op.ValueType  # 41
    """* GTE :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool"""

    LT: BinaryExpr.Op.ValueType  # 42
    """* LT :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool"""

    LTE: BinaryExpr.Op.ValueType  # 44
    """* LTE :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool"""

    MAX: BinaryExpr.Op.ValueType  # 45
    """* Max :: (Comparable a) => (lhs :: a, rhs :: a)  -> a"""

    MIN: BinaryExpr.Op.ValueType  # 46
    """* Min :: (Comparable a) =>  (lhs :: a, rhs :: a)  -> a"""

    INTERSECTION: BinaryExpr.Op.ValueType  # 51
    """* Union :: (Set_Like s, Equality a) => (lhs :: s a, rhs :: s a) -> Set a

    Note how, no matter the type of setlike thing we use as
    input, the output is alwys an unordered set.

    UNION = 50;

    * Intersection :: (Numeric a) => (lhs : Range a, rhs : Range a) -> Range a
    """

    HULL: BinaryExpr.Op.ValueType  # 54
    """* Hull :: (lhs :: Range a, rhs :: Range a) -> Range a
    Given two input ranges, returns the convex hull (union with
    all the inner missing bits filled in)
    """

    WITHIN: BinaryExpr.Op.ValueType  # 53
    """* Intersects :: (Set_Like s, Equality a) => (lhs :: s a, rhs :: s a) -> Bool

    INTERSECTS = 52;

    * Within :: (Numeric a) => (lhs :: Range a, rhs :: Range a) -> Bool
    :: (Numeric a) => (lhs ::       a, rhs :: Range a) -> Bool

    Whether the lhs range or point is entirely within (contained by) the rhs.
    Used to be named SUBSET changed to a name that doesn't also imply a set op.
    """

    RANGE: BinaryExpr.Op.ValueType  # 1
    """* Range :: (Comparable a) => (lower :: a, upper :: a) -> Range a"""


    OP_FIELD_NUMBER: builtins.int
    LHS_FIELD_NUMBER: builtins.int
    RHS_FIELD_NUMBER: builtins.int
    op: global___BinaryExpr.Op.ValueType
    @property
    def lhs(self) -> global___ValueExpr: ...
    @property
    def rhs(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        op: global___BinaryExpr.Op.ValueType = ...,
        lhs: typing.Optional[global___ValueExpr] = ...,
        rhs: typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["lhs",b"lhs","rhs",b"rhs"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["lhs",b"lhs","op",b"op","rhs",b"rhs"]) -> None: ...
global___BinaryExpr = BinaryExpr

class BinarySetExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Op:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[BinarySetExpr._Op.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNDEFINED: BinarySetExpr._Op.ValueType  # 0
        ADD: BinarySetExpr._Op.ValueType  # 10
        """* Add :: Numeric a => (lhset :         Set a, rhs :       a) -> Set a
        :: Numeric a => (lhset :         Set a, rhs : Range a) -> Set (Range a)
        :: Numeric a => (lhset : Set (Range a), rhs :       a) -> Set (Range a)
        :: Numeric a => (lhset : Set (Range a), rhs : Range a) -> Set (Range a)
        """

        MULT: BinarySetExpr._Op.ValueType  # 12
        """* Mult :: Numeric a => (lhset :         Set a, rhs :       a) -> Set a
        :: Numeric a => (lhset :         Set a, rhs : Range a) -> Set (Range a)
        :: Numeric a => (lhset : Set (Range a), rhs :       a) -> Set (Range a)
        :: Numeric a => (lhset : Set (Range a), rhs : Range a) -> Set (Range a)
        """

    class Op(_Op, metaclass=_OpEnumTypeWrapper):
        pass

    UNDEFINED: BinarySetExpr.Op.ValueType  # 0
    ADD: BinarySetExpr.Op.ValueType  # 10
    """* Add :: Numeric a => (lhset :         Set a, rhs :       a) -> Set a
    :: Numeric a => (lhset :         Set a, rhs : Range a) -> Set (Range a)
    :: Numeric a => (lhset : Set (Range a), rhs :       a) -> Set (Range a)
    :: Numeric a => (lhset : Set (Range a), rhs : Range a) -> Set (Range a)
    """

    MULT: BinarySetExpr.Op.ValueType  # 12
    """* Mult :: Numeric a => (lhset :         Set a, rhs :       a) -> Set a
    :: Numeric a => (lhset :         Set a, rhs : Range a) -> Set (Range a)
    :: Numeric a => (lhset : Set (Range a), rhs :       a) -> Set (Range a)
    :: Numeric a => (lhset : Set (Range a), rhs : Range a) -> Set (Range a)
    """


    OP_FIELD_NUMBER: builtins.int
    LHSET_FIELD_NUMBER: builtins.int
    RHS_FIELD_NUMBER: builtins.int
    op: global___BinarySetExpr.Op.ValueType
    @property
    def lhset(self) -> global___ValueExpr: ...
    @property
    def rhs(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        op: global___BinarySetExpr.Op.ValueType = ...,
        lhset: typing.Optional[global___ValueExpr] = ...,
        rhs: typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["lhset",b"lhset","rhs",b"rhs"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["lhset",b"lhset","op",b"op","rhs",b"rhs"]) -> None: ...
global___BinarySetExpr = BinarySetExpr

class RangeExpr(google.protobuf.message.Message):
    """* Arrays have an expression form, allowing you to define them with a set of
    constraints

    message ArrayExpr {
     repeated ValueExpr vals = 1;
     ValueExpr size = 2;
    }

    * Ranges have an expression form, allowing you to constrain them without
    specifying them fully
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    MINIMUM_FIELD_NUMBER: builtins.int
    MAXIMUM_FIELD_NUMBER: builtins.int
    @property
    def minimum(self) -> global___ValueExpr: ...
    @property
    def maximum(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        minimum: typing.Optional[global___ValueExpr] = ...,
        maximum: typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["maximum",b"maximum","minimum",b"minimum"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["maximum",b"maximum","minimum",b"minimum"]) -> None: ...
global___RangeExpr = RangeExpr

class StructExpr(google.protobuf.message.Message):
    """* Structs have an expression form, allowing you to constrain them without
    specifying them fully
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class ValsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        @property
        def value(self) -> global___ValueExpr: ...
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Optional[global___ValueExpr] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    VALS_FIELD_NUMBER: builtins.int
    @property
    def vals(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___ValueExpr]: ...
    def __init__(self,
        *,
        vals: typing.Optional[typing.Mapping[typing.Text, global___ValueExpr]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["vals",b"vals"]) -> None: ...
global___StructExpr = StructExpr

class IfThenElseExpr(google.protobuf.message.Message):
    """* IfThenElse :: (cond :: Bool, tru :: a, fal :: a) -> a"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COND_FIELD_NUMBER: builtins.int
    TRU_FIELD_NUMBER: builtins.int
    FAL_FIELD_NUMBER: builtins.int
    META_FIELD_NUMBER: builtins.int
    @property
    def cond(self) -> global___ValueExpr: ...
    @property
    def tru(self) -> global___ValueExpr: ...
    @property
    def fal(self) -> global___ValueExpr: ...
    @property
    def meta(self) -> edgir.common_pb2.Metadata: ...
    def __init__(self,
        *,
        cond: typing.Optional[global___ValueExpr] = ...,
        tru: typing.Optional[global___ValueExpr] = ...,
        fal: typing.Optional[global___ValueExpr] = ...,
        meta: typing.Optional[edgir.common_pb2.Metadata] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["cond",b"cond","fal",b"fal","meta",b"meta","tru",b"tru"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cond",b"cond","fal",b"fal","meta",b"meta","tru",b"tru"]) -> None: ...
global___IfThenElseExpr = IfThenElseExpr

class ExtractExpr(google.protobuf.message.Message):
    """* Extract :: (container :: Array a           , index :: Int) -> a
    Extract :: (container :: Struct{index :: a}, index :: string)     -> a
    Extract :: (container :: Range a           , index :: {"minimum"|"maximum"}) -> a
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    CONTAINER_FIELD_NUMBER: builtins.int
    INDEX_FIELD_NUMBER: builtins.int
    @property
    def container(self) -> global___ValueExpr: ...
    @property
    def index(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        container: typing.Optional[global___ValueExpr] = ...,
        index: typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["container",b"container","index",b"index"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["container",b"container","index",b"index"]) -> None: ...
global___ExtractExpr = ExtractExpr

class MapExtractExpr(google.protobuf.message.Message):
    """/** MapExtract :: (container :: Array a , path :: LocalRef{from :: a, to :: b}) -> Array b
       MapExtract :: (container :: Set   a , path :: LocalRef{from :: a, to :: b}) -> Set   b

       This expression can map over a container and return a container of
       the relevant subexpression determined by a path. */
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    CONTAINER_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    @property
    def container(self) -> global___ValueExpr: ...
    @property
    def path(self) -> edgir.ref_pb2.LocalPath: ...
    def __init__(self,
        *,
        container: typing.Optional[global___ValueExpr] = ...,
        path: typing.Optional[edgir.ref_pb2.LocalPath] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["container",b"container","path",b"path"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["container",b"container","path",b"path"]) -> None: ...
global___MapExtractExpr = MapExtractExpr

class ConnectedExpr(google.protobuf.message.Message):
    """* isConnected :: Port -> Port -> Bool

    This tells us whether the specified ports are connected
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    BLOCK_PORT_FIELD_NUMBER: builtins.int
    LINK_PORT_FIELD_NUMBER: builtins.int
    @property
    def block_port(self) -> global___ValueExpr: ...
    @property
    def link_port(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        block_port: typing.Optional[global___ValueExpr] = ...,
        link_port: typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["block_port",b"block_port","link_port",b"link_port"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["block_port",b"block_port","link_port",b"link_port"]) -> None: ...
global___ConnectedExpr = ConnectedExpr

class ExportedExpr(google.protobuf.message.Message):
    """* isExported :: Port -> Port -> Bool

    This tells us whether the specified port is exported to the hierarchy block exterior port
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    EXTERIOR_PORT_FIELD_NUMBER: builtins.int
    INTERNAL_BLOCK_PORT_FIELD_NUMBER: builtins.int
    @property
    def exterior_port(self) -> global___ValueExpr: ...
    @property
    def internal_block_port(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        exterior_port: typing.Optional[global___ValueExpr] = ...,
        internal_block_port: typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["exterior_port",b"exterior_port","internal_block_port",b"internal_block_port"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["exterior_port",b"exterior_port","internal_block_port",b"internal_block_port"]) -> None: ...
global___ExportedExpr = ExportedExpr

class AssignExpr(google.protobuf.message.Message):
    """Variable assignment (from an expression value), which allows dataflow to be directioned and explicit.
    Assignments should not be cyclic.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DST_FIELD_NUMBER: builtins.int
    SRC_FIELD_NUMBER: builtins.int
    @property
    def dst(self) -> edgir.ref_pb2.LocalPath: ...
    @property
    def src(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        dst: typing.Optional[edgir.ref_pb2.LocalPath] = ...,
        src: typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dst",b"dst","src",b"src"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dst",b"dst","src",b"src"]) -> None: ...
global___AssignExpr = AssignExpr

class ValueExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    LITERAL_FIELD_NUMBER: builtins.int
    BINARY_FIELD_NUMBER: builtins.int
    BINARY_SET_FIELD_NUMBER: builtins.int
    UNARY_FIELD_NUMBER: builtins.int
    UNARY_SET_FIELD_NUMBER: builtins.int
    STRUCT_FIELD_NUMBER: builtins.int
    RANGE_FIELD_NUMBER: builtins.int
    IFTHENELSE_FIELD_NUMBER: builtins.int
    EXTRACT_FIELD_NUMBER: builtins.int
    MAP_EXTRACT_FIELD_NUMBER: builtins.int
    CONNECTED_FIELD_NUMBER: builtins.int
    EXPORTED_FIELD_NUMBER: builtins.int
    CONNECTEDARRAY_FIELD_NUMBER: builtins.int
    EXPORTEDARRAY_FIELD_NUMBER: builtins.int
    ASSIGN_FIELD_NUMBER: builtins.int
    REF_FIELD_NUMBER: builtins.int
    META_FIELD_NUMBER: builtins.int
    @property
    def literal(self) -> edgir.lit_pb2.ValueLit: ...
    @property
    def binary(self) -> global___BinaryExpr: ...
    @property
    def binary_set(self) -> global___BinarySetExpr: ...
    @property
    def unary(self) -> global___UnaryExpr: ...
    @property
    def unary_set(self) -> global___UnarySetExpr: ...
    @property
    def struct(self) -> global___StructExpr:
        """SetExpr          set         = 5;
        ArrayExpr        array       = 6;
        """
        pass
    @property
    def range(self) -> global___RangeExpr: ...
    @property
    def ifThenElse(self) -> global___IfThenElseExpr: ...
    @property
    def extract(self) -> global___ExtractExpr: ...
    @property
    def map_extract(self) -> global___MapExtractExpr: ...
    @property
    def connected(self) -> global___ConnectedExpr:
        """single port to single port connect"""
        pass
    @property
    def exported(self) -> global___ExportedExpr:
        """single port to single port export"""
        pass
    @property
    def connectedArray(self) -> global___ConnectedExpr:
        """array to array connect, where allocate means allocate a subarray"""
        pass
    @property
    def exportedArray(self) -> global___ExportedExpr:
        """array to array export, where allocate means allocate a subarray"""
        pass
    @property
    def assign(self) -> global___AssignExpr: ...
    @property
    def ref(self) -> edgir.ref_pb2.LocalPath: ...
    @property
    def meta(self) -> edgir.common_pb2.Metadata: ...
    def __init__(self,
        *,
        literal: typing.Optional[edgir.lit_pb2.ValueLit] = ...,
        binary: typing.Optional[global___BinaryExpr] = ...,
        binary_set: typing.Optional[global___BinarySetExpr] = ...,
        unary: typing.Optional[global___UnaryExpr] = ...,
        unary_set: typing.Optional[global___UnarySetExpr] = ...,
        struct: typing.Optional[global___StructExpr] = ...,
        range: typing.Optional[global___RangeExpr] = ...,
        ifThenElse: typing.Optional[global___IfThenElseExpr] = ...,
        extract: typing.Optional[global___ExtractExpr] = ...,
        map_extract: typing.Optional[global___MapExtractExpr] = ...,
        connected: typing.Optional[global___ConnectedExpr] = ...,
        exported: typing.Optional[global___ExportedExpr] = ...,
        connectedArray: typing.Optional[global___ConnectedExpr] = ...,
        exportedArray: typing.Optional[global___ExportedExpr] = ...,
        assign: typing.Optional[global___AssignExpr] = ...,
        ref: typing.Optional[edgir.ref_pb2.LocalPath] = ...,
        meta: typing.Optional[edgir.common_pb2.Metadata] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["assign",b"assign","binary",b"binary","binary_set",b"binary_set","connected",b"connected","connectedArray",b"connectedArray","exported",b"exported","exportedArray",b"exportedArray","expr",b"expr","extract",b"extract","ifThenElse",b"ifThenElse","literal",b"literal","map_extract",b"map_extract","meta",b"meta","range",b"range","ref",b"ref","struct",b"struct","unary",b"unary","unary_set",b"unary_set"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["assign",b"assign","binary",b"binary","binary_set",b"binary_set","connected",b"connected","connectedArray",b"connectedArray","exported",b"exported","exportedArray",b"exportedArray","expr",b"expr","extract",b"extract","ifThenElse",b"ifThenElse","literal",b"literal","map_extract",b"map_extract","meta",b"meta","range",b"range","ref",b"ref","struct",b"struct","unary",b"unary","unary_set",b"unary_set"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["expr",b"expr"]) -> typing.Optional[typing_extensions.Literal["literal","binary","binary_set","unary","unary_set","struct","range","ifThenElse","extract","map_extract","connected","exported","connectedArray","exportedArray","assign","ref"]]: ...
global___ValueExpr = ValueExpr
