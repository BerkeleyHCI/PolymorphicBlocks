"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import edgir.common_pb2
import edgir.lit_pb2
import edgir.ref_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class UnaryExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Op(_Op, metaclass=_OpEnumTypeWrapper):
        pass
    class _Op:
        V = typing.NewType('V', builtins.int)
    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Op.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNDEFINED = UnaryExpr.Op.V(0)
        #* Negate :: Numeric a =>       a -> a
        #:: Numeric a => Range a -> Range a
        NEGATE = UnaryExpr.Op.V(1)
        #* Not :: Bool -> Bool
        NOT = UnaryExpr.Op.V(2)
        #* Invert ::       Float -> Float
        #:: Range Float -> Range Float
        INVERT = UnaryExpr.Op.V(3)
        #* Min :: Range a -> a
        MIN = UnaryExpr.Op.V(4)
        #* Max :: Range a -> a
        MAX = UnaryExpr.Op.V(5)
        #* Center :: Range a -> a
        CENTER = UnaryExpr.Op.V(6)
        #* Width :: Range a -> a
        WIDTH = UnaryExpr.Op.V(7)

    UNDEFINED = UnaryExpr.Op.V(0)
    #* Negate :: Numeric a =>       a -> a
    #:: Numeric a => Range a -> Range a
    NEGATE = UnaryExpr.Op.V(1)
    #* Not :: Bool -> Bool
    NOT = UnaryExpr.Op.V(2)
    #* Invert ::       Float -> Float
    #:: Range Float -> Range Float
    INVERT = UnaryExpr.Op.V(3)
    #* Min :: Range a -> a
    MIN = UnaryExpr.Op.V(4)
    #* Max :: Range a -> a
    MAX = UnaryExpr.Op.V(5)
    #* Center :: Range a -> a
    CENTER = UnaryExpr.Op.V(6)
    #* Width :: Range a -> a
    WIDTH = UnaryExpr.Op.V(7)

    OP_FIELD_NUMBER: builtins.int
    VAL_FIELD_NUMBER: builtins.int
    op: global___UnaryExpr.Op.V = ...
    @property
    def val(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        op : global___UnaryExpr.Op.V = ...,
        val : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"val",b"val"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"op",b"op",u"val",b"val"]) -> None: ...
global___UnaryExpr = UnaryExpr

class UnarySetExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Op(_Op, metaclass=_OpEnumTypeWrapper):
        pass
    class _Op:
        V = typing.NewType('V', builtins.int)
    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Op.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNDEFINED = UnarySetExpr.Op.V(0)
        #* Sum :: (Numeric a) => Set a -> a
        #:: (Numeric a) => Set (Range a) -> Range a
        #
        #Sum({}) = 0
        SUM = UnarySetExpr.Op.V(1)
        #* All :: Set Bool -> Bool
        #
        #All inputs are true
        #All({}) = True
        ALL_TRUE = UnarySetExpr.Op.V(2)
        #* Any :: Set Bool -> Bool
        #
        #Any of the inputs are true
        #Any({}) = False
        ANY_TRUE = UnarySetExpr.Op.V(3)
        #* AllEq :: (Equality a) => Set a -> Bool
        #
        #AllEq({}) = True
        ALL_EQ = UnarySetExpr.Op.V(4)
        #* AllUnique :: (Equality a) => Set a -> Bool
        #
        #AllUnique(EmptySet) = True
        ALL_UNIQUE = UnarySetExpr.Op.V(5)
        #* Size :: Set a -> Integer

        # SIZE = 6;

        #* Maximum :: (Ordered a) => Set a -> a
        #
        #This op requires that the non-emptyness of the relevant set is assured
        #before being valid.
        MAXIMUM = UnarySetExpr.Op.V(10)
        #* Minimum :: (Ordered a) => Set a -> a
        #
        #This op requires that the non-emptyness of the relevant set is assured
        #before being valid.
        MINIMUM = UnarySetExpr.Op.V(11)
        #* SetExtract :: Set a -> a
        #
        #This op requires that the non-emptyness of the relevant set is assured
        #before being valid. In addition this assumes all values in the set are equal.
        SET_EXTRACT = UnarySetExpr.Op.V(12)
        #* Intersection :: Set (Range a) -> Range a
        #
        #May produce an empty range.
        #Intersection({}) = [-inf, +inf]
        INTERSECTION = UnarySetExpr.Op.V(13)
        #* Hull :: Set (Range a) -> Range a
        #Returns the convex hull (union with all the inner missing bits filled in)
        #Hull({}) = EmptyRange
        HULL = UnarySetExpr.Op.V(14)
        #* Negate :: Numeric a => Set a         -> Set a
        #:: Numeric a => Set (Range a) -> Set (Range a)
        #
        #Pointwise negate
        NEGATE = UnarySetExpr.Op.V(20)
        #* Invert :: Set Float         -> Set Float
        #:: Set (Range Float) -> Set (Range Float)
        #
        #Pointwise Invert
        INVERT = UnarySetExpr.Op.V(21)

    UNDEFINED = UnarySetExpr.Op.V(0)
    #* Sum :: (Numeric a) => Set a -> a
    #:: (Numeric a) => Set (Range a) -> Range a
    #
    #Sum({}) = 0
    SUM = UnarySetExpr.Op.V(1)
    #* All :: Set Bool -> Bool
    #
    #All inputs are true
    #All({}) = True
    ALL_TRUE = UnarySetExpr.Op.V(2)
    #* Any :: Set Bool -> Bool
    #
    #Any of the inputs are true
    #Any({}) = False
    ANY_TRUE = UnarySetExpr.Op.V(3)
    #* AllEq :: (Equality a) => Set a -> Bool
    #
    #AllEq({}) = True
    ALL_EQ = UnarySetExpr.Op.V(4)
    #* AllUnique :: (Equality a) => Set a -> Bool
    #
    #AllUnique(EmptySet) = True
    ALL_UNIQUE = UnarySetExpr.Op.V(5)
    #* Size :: Set a -> Integer

    # SIZE = 6;

    #* Maximum :: (Ordered a) => Set a -> a
    #
    #This op requires that the non-emptyness of the relevant set is assured
    #before being valid.
    MAXIMUM = UnarySetExpr.Op.V(10)
    #* Minimum :: (Ordered a) => Set a -> a
    #
    #This op requires that the non-emptyness of the relevant set is assured
    #before being valid.
    MINIMUM = UnarySetExpr.Op.V(11)
    #* SetExtract :: Set a -> a
    #
    #This op requires that the non-emptyness of the relevant set is assured
    #before being valid. In addition this assumes all values in the set are equal.
    SET_EXTRACT = UnarySetExpr.Op.V(12)
    #* Intersection :: Set (Range a) -> Range a
    #
    #May produce an empty range.
    #Intersection({}) = [-inf, +inf]
    INTERSECTION = UnarySetExpr.Op.V(13)
    #* Hull :: Set (Range a) -> Range a
    #Returns the convex hull (union with all the inner missing bits filled in)
    #Hull({}) = EmptyRange
    HULL = UnarySetExpr.Op.V(14)
    #* Negate :: Numeric a => Set a         -> Set a
    #:: Numeric a => Set (Range a) -> Set (Range a)
    #
    #Pointwise negate
    NEGATE = UnarySetExpr.Op.V(20)
    #* Invert :: Set Float         -> Set Float
    #:: Set (Range Float) -> Set (Range Float)
    #
    #Pointwise Invert
    INVERT = UnarySetExpr.Op.V(21)

    OP_FIELD_NUMBER: builtins.int
    VALS_FIELD_NUMBER: builtins.int
    op: global___UnarySetExpr.Op.V = ...
    @property
    def vals(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        op : global___UnarySetExpr.Op.V = ...,
        vals : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"vals",b"vals"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"op",b"op",u"vals",b"vals"]) -> None: ...
global___UnarySetExpr = UnarySetExpr

class BinaryExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Op(_Op, metaclass=_OpEnumTypeWrapper):
        pass
    class _Op:
        V = typing.NewType('V', builtins.int)
    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Op.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNDEFINED = BinaryExpr.Op.V(0)
        #* Add :: Numeric a => (lhs ::       a, rhs ::       a) -> a
        #:: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
        #:: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
        #:: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a
        ADD = BinaryExpr.Op.V(10)
        #* Sub :: Numeric a => (lhs ::       a, rhs ::       a) -> a
        #:: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
        #:: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
        #:: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a

        # SUB = 11; // Use ADD and NEGATE instead

        #* Mult :: Numeric a => (lhs ::       a, rhs ::       a) -> a
        #:: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
        #:: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
        #:: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a
        MULT = BinaryExpr.Op.V(12)
        #* Div :: Numeric a => (lhs ::       a, rhs ::       a) -> a
        #:: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
        #:: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
        #:: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a

        # DIV = 13; // Use MULT and INVERT instead

        #* And :: (lhs :: Bool, rhs :: Bool) -> Bool
        AND = BinaryExpr.Op.V(20)
        #* Or :: (lhs :: Bool, rhs :: Bool) -> Bool
        OR = BinaryExpr.Op.V(21)
        #* Xor :: (lhs :: Bool, rhs :: Bool) -> Bool
        XOR = BinaryExpr.Op.V(22)
        #* Implies :: (lhs :: Bool, rhs :: Bool) -> Bool
        IMPLIES = BinaryExpr.Op.V(23)
        #* Iff :: (lhs :: Bool, rhs :: Bool) -> Bool

        # IFF = 24; // Use EQ instead

        #* Eq :: (Equality a) =>  (lhs :: a, rhs :: a)  -> Bool
        EQ = BinaryExpr.Op.V(30)
        #* Neq :: (Equality a) => (lhs :: a, rhs : a)  -> Bool
        NEQ = BinaryExpr.Op.V(31)
        #* GT :: (Comparable a) =>  (lhs :: a, rhs :: a)  -> Bool
        GT = BinaryExpr.Op.V(40)
        #* GTE :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool
        GTE = BinaryExpr.Op.V(41)
        #* LT :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool
        LT = BinaryExpr.Op.V(42)
        #* LTE :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool
        LTE = BinaryExpr.Op.V(44)
        #* Max :: (Comparable a) => (lhs :: a, rhs :: a)  -> a
        MAX = BinaryExpr.Op.V(45)
        #* Min :: (Comparable a) =>  (lhs :: a, rhs :: a)  -> a
        MIN = BinaryExpr.Op.V(46)
        #* Union :: (Set_Like s, Equality a) => (lhs :: s a, rhs :: s a) -> Set a
        #
        #Note how, no matter the type of setlike thing we use as
        #input, the output is alwys an unordered set.

        # UNION = 50;

        #* Intersection :: (Numeric a) => (lhs : Range a, rhs : Range a) -> Range a
        INTERSECTION = BinaryExpr.Op.V(51)
        #* Hull :: (lhs :: Range a, rhs :: Range a) -> Range a
        #Given two input ranges, returns the convex hull (union with
        #all the inner missing bits filled in)
        HULL = BinaryExpr.Op.V(54)
        #* Intersects :: (Set_Like s, Equality a) => (lhs :: s a, rhs :: s a) -> Bool

        # INTERSECTS = 52;

        #* Within :: (Numeric a) => (lhs :: Range a, rhs :: Range a) -> Bool
        #:: (Numeric a) => (lhs ::       a, rhs :: Range a) -> Bool
        #
        #Whether the lhs range or point is entirely within (contained by) the rhs.
        #Used to be named SUBSET changed to a name that doesn't also imply a set op.
        WITHIN = BinaryExpr.Op.V(53)
        #* Range :: (Comparable a) => (lower :: a, upper :: a) -> Range a
        RANGE = BinaryExpr.Op.V(1)

    UNDEFINED = BinaryExpr.Op.V(0)
    #* Add :: Numeric a => (lhs ::       a, rhs ::       a) -> a
    #:: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
    #:: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
    #:: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a
    ADD = BinaryExpr.Op.V(10)
    #* Sub :: Numeric a => (lhs ::       a, rhs ::       a) -> a
    #:: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
    #:: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
    #:: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a

    # SUB = 11; // Use ADD and NEGATE instead

    #* Mult :: Numeric a => (lhs ::       a, rhs ::       a) -> a
    #:: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
    #:: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
    #:: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a
    MULT = BinaryExpr.Op.V(12)
    #* Div :: Numeric a => (lhs ::       a, rhs ::       a) -> a
    #:: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
    #:: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
    #:: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a

    # DIV = 13; // Use MULT and INVERT instead

    #* And :: (lhs :: Bool, rhs :: Bool) -> Bool
    AND = BinaryExpr.Op.V(20)
    #* Or :: (lhs :: Bool, rhs :: Bool) -> Bool
    OR = BinaryExpr.Op.V(21)
    #* Xor :: (lhs :: Bool, rhs :: Bool) -> Bool
    XOR = BinaryExpr.Op.V(22)
    #* Implies :: (lhs :: Bool, rhs :: Bool) -> Bool
    IMPLIES = BinaryExpr.Op.V(23)
    #* Iff :: (lhs :: Bool, rhs :: Bool) -> Bool

    # IFF = 24; // Use EQ instead

    #* Eq :: (Equality a) =>  (lhs :: a, rhs :: a)  -> Bool
    EQ = BinaryExpr.Op.V(30)
    #* Neq :: (Equality a) => (lhs :: a, rhs : a)  -> Bool
    NEQ = BinaryExpr.Op.V(31)
    #* GT :: (Comparable a) =>  (lhs :: a, rhs :: a)  -> Bool
    GT = BinaryExpr.Op.V(40)
    #* GTE :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool
    GTE = BinaryExpr.Op.V(41)
    #* LT :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool
    LT = BinaryExpr.Op.V(42)
    #* LTE :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool
    LTE = BinaryExpr.Op.V(44)
    #* Max :: (Comparable a) => (lhs :: a, rhs :: a)  -> a
    MAX = BinaryExpr.Op.V(45)
    #* Min :: (Comparable a) =>  (lhs :: a, rhs :: a)  -> a
    MIN = BinaryExpr.Op.V(46)
    #* Union :: (Set_Like s, Equality a) => (lhs :: s a, rhs :: s a) -> Set a
    #
    #Note how, no matter the type of setlike thing we use as
    #input, the output is alwys an unordered set.

    # UNION = 50;

    #* Intersection :: (Numeric a) => (lhs : Range a, rhs : Range a) -> Range a
    INTERSECTION = BinaryExpr.Op.V(51)
    #* Hull :: (lhs :: Range a, rhs :: Range a) -> Range a
    #Given two input ranges, returns the convex hull (union with
    #all the inner missing bits filled in)
    HULL = BinaryExpr.Op.V(54)
    #* Intersects :: (Set_Like s, Equality a) => (lhs :: s a, rhs :: s a) -> Bool

    # INTERSECTS = 52;

    #* Within :: (Numeric a) => (lhs :: Range a, rhs :: Range a) -> Bool
    #:: (Numeric a) => (lhs ::       a, rhs :: Range a) -> Bool
    #
    #Whether the lhs range or point is entirely within (contained by) the rhs.
    #Used to be named SUBSET changed to a name that doesn't also imply a set op.
    WITHIN = BinaryExpr.Op.V(53)
    #* Range :: (Comparable a) => (lower :: a, upper :: a) -> Range a
    RANGE = BinaryExpr.Op.V(1)

    OP_FIELD_NUMBER: builtins.int
    LHS_FIELD_NUMBER: builtins.int
    RHS_FIELD_NUMBER: builtins.int
    op: global___BinaryExpr.Op.V = ...
    @property
    def lhs(self) -> global___ValueExpr: ...
    @property
    def rhs(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        op : global___BinaryExpr.Op.V = ...,
        lhs : typing.Optional[global___ValueExpr] = ...,
        rhs : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"lhs",b"lhs",u"rhs",b"rhs"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"lhs",b"lhs",u"op",b"op",u"rhs",b"rhs"]) -> None: ...
global___BinaryExpr = BinaryExpr

class BinarySetExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Op(_Op, metaclass=_OpEnumTypeWrapper):
        pass
    class _Op:
        V = typing.NewType('V', builtins.int)
    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Op.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNDEFINED = BinarySetExpr.Op.V(0)
        #* Add :: Numeric a => (lhset :         Set a, rhs :       a) -> Set a
        #:: Numeric a => (lhset :         Set a, rhs : Range a) -> Set (Range a)
        #:: Numeric a => (lhset : Set (Range a), rhs :       a) -> Set (Range a)
        #:: Numeric a => (lhset : Set (Range a), rhs : Range a) -> Set (Range a)
        ADD = BinarySetExpr.Op.V(10)
        #* Mult :: Numeric a => (lhset :         Set a, rhs :       a) -> Set a
        #:: Numeric a => (lhset :         Set a, rhs : Range a) -> Set (Range a)
        #:: Numeric a => (lhset : Set (Range a), rhs :       a) -> Set (Range a)
        #:: Numeric a => (lhset : Set (Range a), rhs : Range a) -> Set (Range a)
        MULT = BinarySetExpr.Op.V(12)

    UNDEFINED = BinarySetExpr.Op.V(0)
    #* Add :: Numeric a => (lhset :         Set a, rhs :       a) -> Set a
    #:: Numeric a => (lhset :         Set a, rhs : Range a) -> Set (Range a)
    #:: Numeric a => (lhset : Set (Range a), rhs :       a) -> Set (Range a)
    #:: Numeric a => (lhset : Set (Range a), rhs : Range a) -> Set (Range a)
    ADD = BinarySetExpr.Op.V(10)
    #* Mult :: Numeric a => (lhset :         Set a, rhs :       a) -> Set a
    #:: Numeric a => (lhset :         Set a, rhs : Range a) -> Set (Range a)
    #:: Numeric a => (lhset : Set (Range a), rhs :       a) -> Set (Range a)
    #:: Numeric a => (lhset : Set (Range a), rhs : Range a) -> Set (Range a)
    MULT = BinarySetExpr.Op.V(12)

    OP_FIELD_NUMBER: builtins.int
    LHSET_FIELD_NUMBER: builtins.int
    RHS_FIELD_NUMBER: builtins.int
    op: global___BinarySetExpr.Op.V = ...
    @property
    def lhset(self) -> global___ValueExpr: ...
    @property
    def rhs(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        op : global___BinarySetExpr.Op.V = ...,
        lhset : typing.Optional[global___ValueExpr] = ...,
        rhs : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"lhset",b"lhset",u"rhs",b"rhs"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"lhset",b"lhset",u"op",b"op",u"rhs",b"rhs"]) -> None: ...
global___BinarySetExpr = BinarySetExpr

#* Arrays have an expression form, allowing you to define them with a set of
#constraints

#message ArrayExpr {
#  repeated ValueExpr vals = 1;
#  ValueExpr size = 2;
#}

#* Ranges have an expression form, allowing you to constrain them without
#specifying them fully
class RangeExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MINIMUM_FIELD_NUMBER: builtins.int
    MAXIMUM_FIELD_NUMBER: builtins.int
    @property
    def minimum(self) -> global___ValueExpr: ...
    @property
    def maximum(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        minimum : typing.Optional[global___ValueExpr] = ...,
        maximum : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"maximum",b"maximum",u"minimum",b"minimum"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"maximum",b"maximum",u"minimum",b"minimum"]) -> None: ...
global___RangeExpr = RangeExpr

#* Structs have an expression form, allowing you to constrain them without
#specifying them fully
class StructExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ValsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> global___ValueExpr: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[global___ValueExpr] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    VALS_FIELD_NUMBER: builtins.int
    @property
    def vals(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___ValueExpr]: ...
    def __init__(self,
        *,
        vals : typing.Optional[typing.Mapping[typing.Text, global___ValueExpr]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"vals",b"vals"]) -> None: ...
global___StructExpr = StructExpr

#* IfThenElse :: (cond :: Bool, tru :: a, fal :: a) -> a
class IfThenElseExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    COND_FIELD_NUMBER: builtins.int
    TRU_FIELD_NUMBER: builtins.int
    FAL_FIELD_NUMBER: builtins.int
    META_FIELD_NUMBER: builtins.int
    @property
    def cond(self) -> global___ValueExpr: ...
    @property
    def tru(self) -> global___ValueExpr: ...
    @property
    def fal(self) -> global___ValueExpr: ...
    @property
    def meta(self) -> edgir.common_pb2.Metadata: ...
    def __init__(self,
        *,
        cond : typing.Optional[global___ValueExpr] = ...,
        tru : typing.Optional[global___ValueExpr] = ...,
        fal : typing.Optional[global___ValueExpr] = ...,
        meta : typing.Optional[edgir.common_pb2.Metadata] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"cond",b"cond",u"fal",b"fal",u"meta",b"meta",u"tru",b"tru"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"cond",b"cond",u"fal",b"fal",u"meta",b"meta",u"tru",b"tru"]) -> None: ...
global___IfThenElseExpr = IfThenElseExpr

#* Extract :: (container :: Array a           , index :: Int) -> a
#Extract :: (container :: Struct{index :: a}, index :: string)     -> a
#Extract :: (container :: Range a           , index :: {"minimum"|"maximum"}) -> a
class ExtractExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONTAINER_FIELD_NUMBER: builtins.int
    INDEX_FIELD_NUMBER: builtins.int
    @property
    def container(self) -> global___ValueExpr: ...
    @property
    def index(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        container : typing.Optional[global___ValueExpr] = ...,
        index : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"container",b"container",u"index",b"index"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"container",b"container",u"index",b"index"]) -> None: ...
global___ExtractExpr = ExtractExpr

#/** MapExtract :: (container :: Array a , path :: LocalRef{from :: a, to :: b}) -> Array b
#    MapExtract :: (container :: Set   a , path :: LocalRef{from :: a, to :: b}) -> Set   b
#
#    This expression can map over a container and return a container of
#    the relevant subexpression determined by a path. */
class MapExtractExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONTAINER_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    @property
    def container(self) -> global___ValueExpr: ...
    @property
    def path(self) -> edgir.ref_pb2.LocalPath: ...
    def __init__(self,
        *,
        container : typing.Optional[global___ValueExpr] = ...,
        path : typing.Optional[edgir.ref_pb2.LocalPath] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"container",b"container",u"path",b"path"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"container",b"container",u"path",b"path"]) -> None: ...
global___MapExtractExpr = MapExtractExpr

#* isConnected :: Port -> Port -> Bool
#
#This tells us whether the specified ports are connected
class ConnectedExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    BLOCK_PORT_FIELD_NUMBER: builtins.int
    LINK_PORT_FIELD_NUMBER: builtins.int
    @property
    def block_port(self) -> global___ValueExpr: ...
    @property
    def link_port(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        block_port : typing.Optional[global___ValueExpr] = ...,
        link_port : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"block_port",b"block_port",u"link_port",b"link_port"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"block_port",b"block_port",u"link_port",b"link_port"]) -> None: ...
global___ConnectedExpr = ConnectedExpr

#* isExported :: Port -> Port -> Bool
#
#This tells us whether the specified port is exported to the hierarchy block exterior port
class ExportedExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXTERIOR_PORT_FIELD_NUMBER: builtins.int
    INTERNAL_BLOCK_PORT_FIELD_NUMBER: builtins.int
    @property
    def exterior_port(self) -> global___ValueExpr: ...
    @property
    def internal_block_port(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        exterior_port : typing.Optional[global___ValueExpr] = ...,
        internal_block_port : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"exterior_port",b"exterior_port",u"internal_block_port",b"internal_block_port"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"exterior_port",b"exterior_port",u"internal_block_port",b"internal_block_port"]) -> None: ...
global___ExportedExpr = ExportedExpr

# Variable assignment (from an expression value), which allows dataflow to be directioned and explicit.
# Assignments should not be cyclic.
class AssignExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DST_FIELD_NUMBER: builtins.int
    SRC_FIELD_NUMBER: builtins.int
    @property
    def dst(self) -> edgir.ref_pb2.LocalPath: ...
    @property
    def src(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        dst : typing.Optional[edgir.ref_pb2.LocalPath] = ...,
        src : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"dst",b"dst",u"src",b"src"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"dst",b"dst",u"src",b"src"]) -> None: ...
global___AssignExpr = AssignExpr

class ValueExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    LITERAL_FIELD_NUMBER: builtins.int
    BINARY_FIELD_NUMBER: builtins.int
    BINARY_SET_FIELD_NUMBER: builtins.int
    UNARY_FIELD_NUMBER: builtins.int
    UNARY_SET_FIELD_NUMBER: builtins.int
    STRUCT_FIELD_NUMBER: builtins.int
    RANGE_FIELD_NUMBER: builtins.int
    IFTHENELSE_FIELD_NUMBER: builtins.int
    EXTRACT_FIELD_NUMBER: builtins.int
    MAP_EXTRACT_FIELD_NUMBER: builtins.int
    CONNECTED_FIELD_NUMBER: builtins.int
    EXPORTED_FIELD_NUMBER: builtins.int
    ASSIGN_FIELD_NUMBER: builtins.int
    REF_FIELD_NUMBER: builtins.int
    META_FIELD_NUMBER: builtins.int
    @property
    def literal(self) -> edgir.lit_pb2.ValueLit: ...
    @property
    def binary(self) -> global___BinaryExpr: ...
    @property
    def binary_set(self) -> global___BinarySetExpr: ...
    @property
    def unary(self) -> global___UnaryExpr: ...
    @property
    def unary_set(self) -> global___UnarySetExpr: ...
    # SetExpr          set         = 5;
    # ArrayExpr        array       = 6;
    @property
    def struct(self) -> global___StructExpr: ...
    @property
    def range(self) -> global___RangeExpr: ...
    @property
    def ifThenElse(self) -> global___IfThenElseExpr: ...
    @property
    def extract(self) -> global___ExtractExpr: ...
    @property
    def map_extract(self) -> global___MapExtractExpr: ...
    @property
    def connected(self) -> global___ConnectedExpr: ...
    @property
    def exported(self) -> global___ExportedExpr: ...
    @property
    def assign(self) -> global___AssignExpr: ...
    @property
    def ref(self) -> edgir.ref_pb2.LocalPath: ...
    @property
    def meta(self) -> edgir.common_pb2.Metadata: ...
    def __init__(self,
        *,
        literal : typing.Optional[edgir.lit_pb2.ValueLit] = ...,
        binary : typing.Optional[global___BinaryExpr] = ...,
        binary_set : typing.Optional[global___BinarySetExpr] = ...,
        unary : typing.Optional[global___UnaryExpr] = ...,
        unary_set : typing.Optional[global___UnarySetExpr] = ...,
        struct : typing.Optional[global___StructExpr] = ...,
        range : typing.Optional[global___RangeExpr] = ...,
        ifThenElse : typing.Optional[global___IfThenElseExpr] = ...,
        extract : typing.Optional[global___ExtractExpr] = ...,
        map_extract : typing.Optional[global___MapExtractExpr] = ...,
        connected : typing.Optional[global___ConnectedExpr] = ...,
        exported : typing.Optional[global___ExportedExpr] = ...,
        assign : typing.Optional[global___AssignExpr] = ...,
        ref : typing.Optional[edgir.ref_pb2.LocalPath] = ...,
        meta : typing.Optional[edgir.common_pb2.Metadata] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"assign",b"assign",u"binary",b"binary",u"binary_set",b"binary_set",u"connected",b"connected",u"exported",b"exported",u"expr",b"expr",u"extract",b"extract",u"ifThenElse",b"ifThenElse",u"literal",b"literal",u"map_extract",b"map_extract",u"meta",b"meta",u"range",b"range",u"ref",b"ref",u"struct",b"struct",u"unary",b"unary",u"unary_set",b"unary_set"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"assign",b"assign",u"binary",b"binary",u"binary_set",b"binary_set",u"connected",b"connected",u"exported",b"exported",u"expr",b"expr",u"extract",b"extract",u"ifThenElse",b"ifThenElse",u"literal",b"literal",u"map_extract",b"map_extract",u"meta",b"meta",u"range",b"range",u"ref",b"ref",u"struct",b"struct",u"unary",b"unary",u"unary_set",b"unary_set"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"expr",b"expr"]) -> typing.Optional[typing_extensions.Literal["literal","binary","binary_set","unary","unary_set","struct","range","ifThenElse","extract","map_extract","connected","exported","assign","ref"]]: ...
global___ValueExpr = ValueExpr
