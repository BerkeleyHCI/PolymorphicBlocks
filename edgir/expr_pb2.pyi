"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import edgir.common_pb2
import edgir.lit_pb2
import edgir.ref_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class UnaryExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Op(_Op, metaclass=_OpEnumTypeWrapper):
        pass
    class _Op:
        V = typing.NewType('V', builtins.int)
    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Op.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNDEFINED = UnaryExpr.Op.V(0)
        NEGATE = UnaryExpr.Op.V(1)
        """* Negate :: Numeric a =>       a -> a
        :: Numeric a => Range a -> Range a
        """

        NOT = UnaryExpr.Op.V(2)
        """* Not :: Bool -> Bool"""

        INVERT = UnaryExpr.Op.V(3)
        """* Invert ::       Float -> Float
        :: Range Float -> Range Float
        """

        MIN = UnaryExpr.Op.V(4)
        """* Min :: Range a -> a"""

        MAX = UnaryExpr.Op.V(5)
        """* Max :: Range a -> a"""

        CENTER = UnaryExpr.Op.V(6)
        """* Center :: Range a -> a"""

        WIDTH = UnaryExpr.Op.V(7)
        """* Width :: Range a -> a"""


    UNDEFINED = UnaryExpr.Op.V(0)
    NEGATE = UnaryExpr.Op.V(1)
    """* Negate :: Numeric a =>       a -> a
    :: Numeric a => Range a -> Range a
    """

    NOT = UnaryExpr.Op.V(2)
    """* Not :: Bool -> Bool"""

    INVERT = UnaryExpr.Op.V(3)
    """* Invert ::       Float -> Float
    :: Range Float -> Range Float
    """

    MIN = UnaryExpr.Op.V(4)
    """* Min :: Range a -> a"""

    MAX = UnaryExpr.Op.V(5)
    """* Max :: Range a -> a"""

    CENTER = UnaryExpr.Op.V(6)
    """* Center :: Range a -> a"""

    WIDTH = UnaryExpr.Op.V(7)
    """* Width :: Range a -> a"""


    OP_FIELD_NUMBER: builtins.int
    VAL_FIELD_NUMBER: builtins.int
    op: global___UnaryExpr.Op.V = ...
    @property
    def val(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        op : global___UnaryExpr.Op.V = ...,
        val : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["val",b"val"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["op",b"op","val",b"val"]) -> None: ...
global___UnaryExpr = UnaryExpr

class UnarySetExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Op(_Op, metaclass=_OpEnumTypeWrapper):
        pass
    class _Op:
        V = typing.NewType('V', builtins.int)
    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Op.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNDEFINED = UnarySetExpr.Op.V(0)
        SUM = UnarySetExpr.Op.V(1)
        """* Sum :: (Numeric a) => Set a -> a
        :: (Numeric a) => Set (Range a) -> Range a

        Sum({}) = 0
        """

        ALL_TRUE = UnarySetExpr.Op.V(2)
        """* All :: Set Bool -> Bool

        All inputs are true
        All({}) = True
        """

        ANY_TRUE = UnarySetExpr.Op.V(3)
        """* Any :: Set Bool -> Bool

        Any of the inputs are true
        Any({}) = False
        """

        ALL_EQ = UnarySetExpr.Op.V(4)
        """* AllEq :: (Equality a) => Set a -> Bool

        AllEq({}) = True
        """

        ALL_UNIQUE = UnarySetExpr.Op.V(5)
        """* AllUnique :: (Equality a) => Set a -> Bool

        AllUnique(EmptySet) = True
        """

        MAXIMUM = UnarySetExpr.Op.V(10)
        """* Size :: Set a -> Integer

        SIZE = 6;

        * Maximum :: (Ordered a) => Set a -> a

        This op requires that the non-emptyness of the relevant set is assured
        before being valid.
        """

        MINIMUM = UnarySetExpr.Op.V(11)
        """* Minimum :: (Ordered a) => Set a -> a

        This op requires that the non-emptyness of the relevant set is assured
        before being valid.
        """

        SET_EXTRACT = UnarySetExpr.Op.V(12)
        """* SetExtract :: Set a -> a

        This op requires that the non-emptyness of the relevant set is assured
        before being valid. In addition this assumes all values in the set are equal.
        """

        INTERSECTION = UnarySetExpr.Op.V(13)
        """* Intersection :: Set (Range a) -> Range a

        May produce an empty range.
        Intersection({}) = [-inf, +inf]
        """

        HULL = UnarySetExpr.Op.V(14)
        """* Hull :: Set (Range a) -> Range a
        Returns the convex hull (union with all the inner missing bits filled in)
        Hull({}) = EmptyRange
        """

        NEGATE = UnarySetExpr.Op.V(20)
        """* Negate :: Numeric a => Set a         -> Set a
        :: Numeric a => Set (Range a) -> Set (Range a)

        Pointwise negate
        """

        INVERT = UnarySetExpr.Op.V(21)
        """* Invert :: Set Float         -> Set Float
        :: Set (Range Float) -> Set (Range Float)

        Pointwise Invert
        """

        FLATTEN = UnarySetExpr.Op.V(30)
        """Flatten[A] : Set[Set[A]] -> Set[A]
        Given an array of array of elements, flattens the inner array.
        Alternatively stated, concatenates all of the elements of the outer arrary
        """


    UNDEFINED = UnarySetExpr.Op.V(0)
    SUM = UnarySetExpr.Op.V(1)
    """* Sum :: (Numeric a) => Set a -> a
    :: (Numeric a) => Set (Range a) -> Range a

    Sum({}) = 0
    """

    ALL_TRUE = UnarySetExpr.Op.V(2)
    """* All :: Set Bool -> Bool

    All inputs are true
    All({}) = True
    """

    ANY_TRUE = UnarySetExpr.Op.V(3)
    """* Any :: Set Bool -> Bool

    Any of the inputs are true
    Any({}) = False
    """

    ALL_EQ = UnarySetExpr.Op.V(4)
    """* AllEq :: (Equality a) => Set a -> Bool

    AllEq({}) = True
    """

    ALL_UNIQUE = UnarySetExpr.Op.V(5)
    """* AllUnique :: (Equality a) => Set a -> Bool

    AllUnique(EmptySet) = True
    """

    MAXIMUM = UnarySetExpr.Op.V(10)
    """* Size :: Set a -> Integer

    SIZE = 6;

    * Maximum :: (Ordered a) => Set a -> a

    This op requires that the non-emptyness of the relevant set is assured
    before being valid.
    """

    MINIMUM = UnarySetExpr.Op.V(11)
    """* Minimum :: (Ordered a) => Set a -> a

    This op requires that the non-emptyness of the relevant set is assured
    before being valid.
    """

    SET_EXTRACT = UnarySetExpr.Op.V(12)
    """* SetExtract :: Set a -> a

    This op requires that the non-emptyness of the relevant set is assured
    before being valid. In addition this assumes all values in the set are equal.
    """

    INTERSECTION = UnarySetExpr.Op.V(13)
    """* Intersection :: Set (Range a) -> Range a

    May produce an empty range.
    Intersection({}) = [-inf, +inf]
    """

    HULL = UnarySetExpr.Op.V(14)
    """* Hull :: Set (Range a) -> Range a
    Returns the convex hull (union with all the inner missing bits filled in)
    Hull({}) = EmptyRange
    """

    NEGATE = UnarySetExpr.Op.V(20)
    """* Negate :: Numeric a => Set a         -> Set a
    :: Numeric a => Set (Range a) -> Set (Range a)

    Pointwise negate
    """

    INVERT = UnarySetExpr.Op.V(21)
    """* Invert :: Set Float         -> Set Float
    :: Set (Range Float) -> Set (Range Float)

    Pointwise Invert
    """

    FLATTEN = UnarySetExpr.Op.V(30)
    """Flatten[A] : Set[Set[A]] -> Set[A]
    Given an array of array of elements, flattens the inner array.
    Alternatively stated, concatenates all of the elements of the outer arrary
    """


    OP_FIELD_NUMBER: builtins.int
    VALS_FIELD_NUMBER: builtins.int
    op: global___UnarySetExpr.Op.V = ...
    @property
    def vals(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        op : global___UnarySetExpr.Op.V = ...,
        vals : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["vals",b"vals"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["op",b"op","vals",b"vals"]) -> None: ...
global___UnarySetExpr = UnarySetExpr

class BinaryExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Op(_Op, metaclass=_OpEnumTypeWrapper):
        pass
    class _Op:
        V = typing.NewType('V', builtins.int)
    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Op.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNDEFINED = BinaryExpr.Op.V(0)
        ADD = BinaryExpr.Op.V(10)
        """* Add :: Numeric a => (lhs ::       a, rhs ::       a) -> a
        :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a
        """

        MULT = BinaryExpr.Op.V(12)
        """* Sub :: Numeric a => (lhs ::       a, rhs ::       a) -> a
        :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a

        SUB = 11; // Use ADD and NEGATE instead

        * Mult :: Numeric a => (lhs ::       a, rhs ::       a) -> a
        :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a
        """

        AND = BinaryExpr.Op.V(20)
        """* Div :: Numeric a => (lhs ::       a, rhs ::       a) -> a
        :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
        :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a

        DIV = 13; // Use MULT and INVERT instead

        * And :: (lhs :: Bool, rhs :: Bool) -> Bool
        """

        OR = BinaryExpr.Op.V(21)
        """* Or :: (lhs :: Bool, rhs :: Bool) -> Bool"""

        XOR = BinaryExpr.Op.V(22)
        """* Xor :: (lhs :: Bool, rhs :: Bool) -> Bool"""

        IMPLIES = BinaryExpr.Op.V(23)
        """* Implies :: (lhs :: Bool, rhs :: Bool) -> Bool"""

        EQ = BinaryExpr.Op.V(30)
        """* Iff :: (lhs :: Bool, rhs :: Bool) -> Bool

        IFF = 24; // Use EQ instead

        * Eq :: (Equality a) =>  (lhs :: a, rhs :: a)  -> Bool
        """

        NEQ = BinaryExpr.Op.V(31)
        """* Neq :: (Equality a) => (lhs :: a, rhs : a)  -> Bool"""

        GT = BinaryExpr.Op.V(40)
        """* GT :: (Comparable a) =>  (lhs :: a, rhs :: a)  -> Bool"""

        GTE = BinaryExpr.Op.V(41)
        """* GTE :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool"""

        LT = BinaryExpr.Op.V(42)
        """* LT :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool"""

        LTE = BinaryExpr.Op.V(44)
        """* LTE :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool"""

        MAX = BinaryExpr.Op.V(45)
        """* Max :: (Comparable a) => (lhs :: a, rhs :: a)  -> a"""

        MIN = BinaryExpr.Op.V(46)
        """* Min :: (Comparable a) =>  (lhs :: a, rhs :: a)  -> a"""

        INTERSECTION = BinaryExpr.Op.V(51)
        """* Union :: (Set_Like s, Equality a) => (lhs :: s a, rhs :: s a) -> Set a

        Note how, no matter the type of setlike thing we use as
        input, the output is alwys an unordered set.

        UNION = 50;

        * Intersection :: (Numeric a) => (lhs : Range a, rhs : Range a) -> Range a
        """

        HULL = BinaryExpr.Op.V(54)
        """* Hull :: (lhs :: Range a, rhs :: Range a) -> Range a
        Given two input ranges, returns the convex hull (union with
        all the inner missing bits filled in)
        """

        WITHIN = BinaryExpr.Op.V(53)
        """* Intersects :: (Set_Like s, Equality a) => (lhs :: s a, rhs :: s a) -> Bool

        INTERSECTS = 52;

        * Within :: (Numeric a) => (lhs :: Range a, rhs :: Range a) -> Bool
        :: (Numeric a) => (lhs ::       a, rhs :: Range a) -> Bool

        Whether the lhs range or point is entirely within (contained by) the rhs.
        Used to be named SUBSET changed to a name that doesn't also imply a set op.
        """

        RANGE = BinaryExpr.Op.V(1)
        """* Range :: (Comparable a) => (lower :: a, upper :: a) -> Range a"""


    UNDEFINED = BinaryExpr.Op.V(0)
    ADD = BinaryExpr.Op.V(10)
    """* Add :: Numeric a => (lhs ::       a, rhs ::       a) -> a
    :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a
    """

    MULT = BinaryExpr.Op.V(12)
    """* Sub :: Numeric a => (lhs ::       a, rhs ::       a) -> a
    :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a

    SUB = 11; // Use ADD and NEGATE instead

    * Mult :: Numeric a => (lhs ::       a, rhs ::       a) -> a
    :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a
    """

    AND = BinaryExpr.Op.V(20)
    """* Div :: Numeric a => (lhs ::       a, rhs ::       a) -> a
    :: Numeric a => (lhs ::       a, rhs :: Range a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs ::       a) -> Range a
    :: Numeric a => (lhs :: Range a, rhs :: Range a) -> Range a

    DIV = 13; // Use MULT and INVERT instead

    * And :: (lhs :: Bool, rhs :: Bool) -> Bool
    """

    OR = BinaryExpr.Op.V(21)
    """* Or :: (lhs :: Bool, rhs :: Bool) -> Bool"""

    XOR = BinaryExpr.Op.V(22)
    """* Xor :: (lhs :: Bool, rhs :: Bool) -> Bool"""

    IMPLIES = BinaryExpr.Op.V(23)
    """* Implies :: (lhs :: Bool, rhs :: Bool) -> Bool"""

    EQ = BinaryExpr.Op.V(30)
    """* Iff :: (lhs :: Bool, rhs :: Bool) -> Bool

    IFF = 24; // Use EQ instead

    * Eq :: (Equality a) =>  (lhs :: a, rhs :: a)  -> Bool
    """

    NEQ = BinaryExpr.Op.V(31)
    """* Neq :: (Equality a) => (lhs :: a, rhs : a)  -> Bool"""

    GT = BinaryExpr.Op.V(40)
    """* GT :: (Comparable a) =>  (lhs :: a, rhs :: a)  -> Bool"""

    GTE = BinaryExpr.Op.V(41)
    """* GTE :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool"""

    LT = BinaryExpr.Op.V(42)
    """* LT :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool"""

    LTE = BinaryExpr.Op.V(44)
    """* LTE :: (Comparable a) =>  (lhs :: a, rhs :: a) -> Bool"""

    MAX = BinaryExpr.Op.V(45)
    """* Max :: (Comparable a) => (lhs :: a, rhs :: a)  -> a"""

    MIN = BinaryExpr.Op.V(46)
    """* Min :: (Comparable a) =>  (lhs :: a, rhs :: a)  -> a"""

    INTERSECTION = BinaryExpr.Op.V(51)
    """* Union :: (Set_Like s, Equality a) => (lhs :: s a, rhs :: s a) -> Set a

    Note how, no matter the type of setlike thing we use as
    input, the output is alwys an unordered set.

    UNION = 50;

    * Intersection :: (Numeric a) => (lhs : Range a, rhs : Range a) -> Range a
    """

    HULL = BinaryExpr.Op.V(54)
    """* Hull :: (lhs :: Range a, rhs :: Range a) -> Range a
    Given two input ranges, returns the convex hull (union with
    all the inner missing bits filled in)
    """

    WITHIN = BinaryExpr.Op.V(53)
    """* Intersects :: (Set_Like s, Equality a) => (lhs :: s a, rhs :: s a) -> Bool

    INTERSECTS = 52;

    * Within :: (Numeric a) => (lhs :: Range a, rhs :: Range a) -> Bool
    :: (Numeric a) => (lhs ::       a, rhs :: Range a) -> Bool

    Whether the lhs range or point is entirely within (contained by) the rhs.
    Used to be named SUBSET changed to a name that doesn't also imply a set op.
    """

    RANGE = BinaryExpr.Op.V(1)
    """* Range :: (Comparable a) => (lower :: a, upper :: a) -> Range a"""


    OP_FIELD_NUMBER: builtins.int
    LHS_FIELD_NUMBER: builtins.int
    RHS_FIELD_NUMBER: builtins.int
    op: global___BinaryExpr.Op.V = ...
    @property
    def lhs(self) -> global___ValueExpr: ...
    @property
    def rhs(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        op : global___BinaryExpr.Op.V = ...,
        lhs : typing.Optional[global___ValueExpr] = ...,
        rhs : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["lhs",b"lhs","rhs",b"rhs"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["lhs",b"lhs","op",b"op","rhs",b"rhs"]) -> None: ...
global___BinaryExpr = BinaryExpr

class BinarySetExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Op(_Op, metaclass=_OpEnumTypeWrapper):
        pass
    class _Op:
        V = typing.NewType('V', builtins.int)
    class _OpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Op.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNDEFINED = BinarySetExpr.Op.V(0)
        ADD = BinarySetExpr.Op.V(10)
        """* Add :: Numeric a => (lhset :         Set a, rhs :       a) -> Set a
        :: Numeric a => (lhset :         Set a, rhs : Range a) -> Set (Range a)
        :: Numeric a => (lhset : Set (Range a), rhs :       a) -> Set (Range a)
        :: Numeric a => (lhset : Set (Range a), rhs : Range a) -> Set (Range a)
        """

        MULT = BinarySetExpr.Op.V(12)
        """* Mult :: Numeric a => (lhset :         Set a, rhs :       a) -> Set a
        :: Numeric a => (lhset :         Set a, rhs : Range a) -> Set (Range a)
        :: Numeric a => (lhset : Set (Range a), rhs :       a) -> Set (Range a)
        :: Numeric a => (lhset : Set (Range a), rhs : Range a) -> Set (Range a)
        """

        CONCAT = BinarySetExpr.Op.V(20)
        """String concatenate operator
        Concatenate : (lhs: String, rhss: Set[String]) -> Set[String] (prepend lhs to all elements)
                    : (lhss: Set[String], rhs: String) -> Set[String] (append rhs to all elements)
        """


    UNDEFINED = BinarySetExpr.Op.V(0)
    ADD = BinarySetExpr.Op.V(10)
    """* Add :: Numeric a => (lhset :         Set a, rhs :       a) -> Set a
    :: Numeric a => (lhset :         Set a, rhs : Range a) -> Set (Range a)
    :: Numeric a => (lhset : Set (Range a), rhs :       a) -> Set (Range a)
    :: Numeric a => (lhset : Set (Range a), rhs : Range a) -> Set (Range a)
    """

    MULT = BinarySetExpr.Op.V(12)
    """* Mult :: Numeric a => (lhset :         Set a, rhs :       a) -> Set a
    :: Numeric a => (lhset :         Set a, rhs : Range a) -> Set (Range a)
    :: Numeric a => (lhset : Set (Range a), rhs :       a) -> Set (Range a)
    :: Numeric a => (lhset : Set (Range a), rhs : Range a) -> Set (Range a)
    """

    CONCAT = BinarySetExpr.Op.V(20)
    """String concatenate operator
    Concatenate : (lhs: String, rhss: Set[String]) -> Set[String] (prepend lhs to all elements)
                : (lhss: Set[String], rhs: String) -> Set[String] (append rhs to all elements)
    """


    OP_FIELD_NUMBER: builtins.int
    LHSET_FIELD_NUMBER: builtins.int
    RHS_FIELD_NUMBER: builtins.int
    op: global___BinarySetExpr.Op.V = ...
    @property
    def lhset(self) -> global___ValueExpr: ...
    @property
    def rhs(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        op : global___BinarySetExpr.Op.V = ...,
        lhset : typing.Optional[global___ValueExpr] = ...,
        rhs : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["lhset",b"lhset","rhs",b"rhs"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["lhset",b"lhset","op",b"op","rhs",b"rhs"]) -> None: ...
global___BinarySetExpr = BinarySetExpr

class ArrayExpr(google.protobuf.message.Message):
    """* Creates an array from element exprs"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    VALS_FIELD_NUMBER: builtins.int
    @property
    def vals(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ValueExpr]: ...
    def __init__(self,
        *,
        vals : typing.Optional[typing.Iterable[global___ValueExpr]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["vals",b"vals"]) -> None: ...
global___ArrayExpr = ArrayExpr

class RangeExpr(google.protobuf.message.Message):
    """* Ranges have an expression form, allowing you to constrain them without
    specifying them fully
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MINIMUM_FIELD_NUMBER: builtins.int
    MAXIMUM_FIELD_NUMBER: builtins.int
    @property
    def minimum(self) -> global___ValueExpr: ...
    @property
    def maximum(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        minimum : typing.Optional[global___ValueExpr] = ...,
        maximum : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["maximum",b"maximum","minimum",b"minimum"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["maximum",b"maximum","minimum",b"minimum"]) -> None: ...
global___RangeExpr = RangeExpr

class StructExpr(google.protobuf.message.Message):
    """* Structs have an expression form, allowing you to constrain them without
    specifying them fully
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ValsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> global___ValueExpr: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[global___ValueExpr] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    VALS_FIELD_NUMBER: builtins.int
    @property
    def vals(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___ValueExpr]: ...
    def __init__(self,
        *,
        vals : typing.Optional[typing.Mapping[typing.Text, global___ValueExpr]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["vals",b"vals"]) -> None: ...
global___StructExpr = StructExpr

class IfThenElseExpr(google.protobuf.message.Message):
    """* IfThenElse :: (cond :: Bool, tru :: a, fal :: a) -> a"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    COND_FIELD_NUMBER: builtins.int
    TRU_FIELD_NUMBER: builtins.int
    FAL_FIELD_NUMBER: builtins.int
    META_FIELD_NUMBER: builtins.int
    @property
    def cond(self) -> global___ValueExpr: ...
    @property
    def tru(self) -> global___ValueExpr: ...
    @property
    def fal(self) -> global___ValueExpr: ...
    @property
    def meta(self) -> edgir.common_pb2.Metadata: ...
    def __init__(self,
        *,
        cond : typing.Optional[global___ValueExpr] = ...,
        tru : typing.Optional[global___ValueExpr] = ...,
        fal : typing.Optional[global___ValueExpr] = ...,
        meta : typing.Optional[edgir.common_pb2.Metadata] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["cond",b"cond","fal",b"fal","meta",b"meta","tru",b"tru"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cond",b"cond","fal",b"fal","meta",b"meta","tru",b"tru"]) -> None: ...
global___IfThenElseExpr = IfThenElseExpr

class ExtractExpr(google.protobuf.message.Message):
    """* Extract :: (container :: Array a           , index :: Int) -> a
    Extract :: (container :: Struct{index :: a}, index :: string)     -> a
    Extract :: (container :: Range a           , index :: {"minimum"|"maximum"}) -> a
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONTAINER_FIELD_NUMBER: builtins.int
    INDEX_FIELD_NUMBER: builtins.int
    @property
    def container(self) -> global___ValueExpr: ...
    @property
    def index(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        container : typing.Optional[global___ValueExpr] = ...,
        index : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["container",b"container","index",b"index"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["container",b"container","index",b"index"]) -> None: ...
global___ExtractExpr = ExtractExpr

class MapExtractExpr(google.protobuf.message.Message):
    """/** MapExtract :: (container :: Array a , path :: LocalRef{from :: a, to :: b}) -> Array b
       MapExtract :: (container :: Set   a , path :: LocalRef{from :: a, to :: b}) -> Set   b

       This expression can map over a container and return a container of
       the relevant subexpression determined by a path. */
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONTAINER_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    @property
    def container(self) -> global___ValueExpr: ...
    @property
    def path(self) -> edgir.ref_pb2.LocalPath: ...
    def __init__(self,
        *,
        container : typing.Optional[global___ValueExpr] = ...,
        path : typing.Optional[edgir.ref_pb2.LocalPath] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["container",b"container","path",b"path"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["container",b"container","path",b"path"]) -> None: ...
global___MapExtractExpr = MapExtractExpr

class ConnectedExpr(google.protobuf.message.Message):
    """* isConnected :: Port -> Port -> Bool

    This tells us whether the specified ports are connected
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    BLOCK_PORT_FIELD_NUMBER: builtins.int
    LINK_PORT_FIELD_NUMBER: builtins.int
    @property
    def block_port(self) -> global___ValueExpr: ...
    @property
    def link_port(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        block_port : typing.Optional[global___ValueExpr] = ...,
        link_port : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["block_port",b"block_port","link_port",b"link_port"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["block_port",b"block_port","link_port",b"link_port"]) -> None: ...
global___ConnectedExpr = ConnectedExpr

class ExportedExpr(google.protobuf.message.Message):
    """* isExported :: Port -> Port -> Bool

    This tells us whether the specified port is exported to the hierarchy block exterior port
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXTERIOR_PORT_FIELD_NUMBER: builtins.int
    INTERNAL_BLOCK_PORT_FIELD_NUMBER: builtins.int
    @property
    def exterior_port(self) -> global___ValueExpr: ...
    @property
    def internal_block_port(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        exterior_port : typing.Optional[global___ValueExpr] = ...,
        internal_block_port : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["exterior_port",b"exterior_port","internal_block_port",b"internal_block_port"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["exterior_port",b"exterior_port","internal_block_port",b"internal_block_port"]) -> None: ...
global___ExportedExpr = ExportedExpr

class AssignExpr(google.protobuf.message.Message):
    """Variable assignment (from an expression value), which allows dataflow to be directioned and explicit.
    Assignments should not be cyclic.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DST_FIELD_NUMBER: builtins.int
    SRC_FIELD_NUMBER: builtins.int
    @property
    def dst(self) -> edgir.ref_pb2.LocalPath: ...
    @property
    def src(self) -> global___ValueExpr: ...
    def __init__(self,
        *,
        dst : typing.Optional[edgir.ref_pb2.LocalPath] = ...,
        src : typing.Optional[global___ValueExpr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dst",b"dst","src",b"src"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dst",b"dst","src",b"src"]) -> None: ...
global___AssignExpr = AssignExpr

class ValueExpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    LITERAL_FIELD_NUMBER: builtins.int
    BINARY_FIELD_NUMBER: builtins.int
    BINARY_SET_FIELD_NUMBER: builtins.int
    UNARY_FIELD_NUMBER: builtins.int
    UNARY_SET_FIELD_NUMBER: builtins.int
    ARRAY_FIELD_NUMBER: builtins.int
    STRUCT_FIELD_NUMBER: builtins.int
    RANGE_FIELD_NUMBER: builtins.int
    IFTHENELSE_FIELD_NUMBER: builtins.int
    EXTRACT_FIELD_NUMBER: builtins.int
    MAP_EXTRACT_FIELD_NUMBER: builtins.int
    CONNECTED_FIELD_NUMBER: builtins.int
    EXPORTED_FIELD_NUMBER: builtins.int
    CONNECTEDARRAY_FIELD_NUMBER: builtins.int
    EXPORTEDARRAY_FIELD_NUMBER: builtins.int
    ASSIGN_FIELD_NUMBER: builtins.int
    EXPORTEDTUNNEL_FIELD_NUMBER: builtins.int
    ASSIGNTUNNEL_FIELD_NUMBER: builtins.int
    REF_FIELD_NUMBER: builtins.int
    META_FIELD_NUMBER: builtins.int
    @property
    def literal(self) -> edgir.lit_pb2.ValueLit: ...
    @property
    def binary(self) -> global___BinaryExpr: ...
    @property
    def binary_set(self) -> global___BinarySetExpr: ...
    @property
    def unary(self) -> global___UnaryExpr: ...
    @property
    def unary_set(self) -> global___UnarySetExpr: ...
    @property
    def array(self) -> global___ArrayExpr:
        """SetExpr          set         = 5;"""
        pass
    @property
    def struct(self) -> global___StructExpr: ...
    @property
    def range(self) -> global___RangeExpr: ...
    @property
    def ifThenElse(self) -> global___IfThenElseExpr: ...
    @property
    def extract(self) -> global___ExtractExpr: ...
    @property
    def map_extract(self) -> global___MapExtractExpr: ...
    @property
    def connected(self) -> global___ConnectedExpr:
        """single port to single port connect"""
        pass
    @property
    def exported(self) -> global___ExportedExpr:
        """single port to single port export"""
        pass
    @property
    def connectedArray(self) -> global___ConnectedExpr:
        """array to array connect, where allocate means allocate a subarray"""
        pass
    @property
    def exportedArray(self) -> global___ExportedExpr:
        """array to array export, where allocate means allocate a subarray"""
        pass
    @property
    def assign(self) -> global___AssignExpr: ...
    @property
    def exportedTunnel(self) -> global___ExportedExpr:
        """These Exprs support cross-hierarchy operations
        single port to single port tunneling (cross-hierarchy) export:
        """
        pass
    @property
    def assignTunnel(self) -> global___AssignExpr:
        """- the exterior port may be a top-level port on any (recursive) sub-block
          for the exterior port, all path components except the last must be block
          references, and the last must be a top-level port
        - exterior ports may not have other internal connections (over-connected)
        - the interior port may be a port of a (direct) sub-block, and may be an
          ALLOCATE on an array
        - interior ports may not have other external connections (over-connected)
        - other, semantically this behaves like a normal export

        parameter assignment which may be cross-hierarchy
        """
        pass
    @property
    def ref(self) -> edgir.ref_pb2.LocalPath: ...
    @property
    def meta(self) -> edgir.common_pb2.Metadata: ...
    def __init__(self,
        *,
        literal : typing.Optional[edgir.lit_pb2.ValueLit] = ...,
        binary : typing.Optional[global___BinaryExpr] = ...,
        binary_set : typing.Optional[global___BinarySetExpr] = ...,
        unary : typing.Optional[global___UnaryExpr] = ...,
        unary_set : typing.Optional[global___UnarySetExpr] = ...,
        array : typing.Optional[global___ArrayExpr] = ...,
        struct : typing.Optional[global___StructExpr] = ...,
        range : typing.Optional[global___RangeExpr] = ...,
        ifThenElse : typing.Optional[global___IfThenElseExpr] = ...,
        extract : typing.Optional[global___ExtractExpr] = ...,
        map_extract : typing.Optional[global___MapExtractExpr] = ...,
        connected : typing.Optional[global___ConnectedExpr] = ...,
        exported : typing.Optional[global___ExportedExpr] = ...,
        connectedArray : typing.Optional[global___ConnectedExpr] = ...,
        exportedArray : typing.Optional[global___ExportedExpr] = ...,
        assign : typing.Optional[global___AssignExpr] = ...,
        exportedTunnel : typing.Optional[global___ExportedExpr] = ...,
        assignTunnel : typing.Optional[global___AssignExpr] = ...,
        ref : typing.Optional[edgir.ref_pb2.LocalPath] = ...,
        meta : typing.Optional[edgir.common_pb2.Metadata] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["array",b"array","assign",b"assign","assignTunnel",b"assignTunnel","binary",b"binary","binary_set",b"binary_set","connected",b"connected","connectedArray",b"connectedArray","exported",b"exported","exportedArray",b"exportedArray","exportedTunnel",b"exportedTunnel","expr",b"expr","extract",b"extract","ifThenElse",b"ifThenElse","literal",b"literal","map_extract",b"map_extract","meta",b"meta","range",b"range","ref",b"ref","struct",b"struct","unary",b"unary","unary_set",b"unary_set"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["array",b"array","assign",b"assign","assignTunnel",b"assignTunnel","binary",b"binary","binary_set",b"binary_set","connected",b"connected","connectedArray",b"connectedArray","exported",b"exported","exportedArray",b"exportedArray","exportedTunnel",b"exportedTunnel","expr",b"expr","extract",b"extract","ifThenElse",b"ifThenElse","literal",b"literal","map_extract",b"map_extract","meta",b"meta","range",b"range","ref",b"ref","struct",b"struct","unary",b"unary","unary_set",b"unary_set"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["expr",b"expr"]) -> typing.Optional[typing_extensions.Literal["literal","binary","binary_set","unary","unary_set","array","struct","range","ifThenElse","extract","map_extract","connected","exported","connectedArray","exportedArray","assign","exportedTunnel","assignTunnel","ref"]]: ...
global___ValueExpr = ValueExpr
