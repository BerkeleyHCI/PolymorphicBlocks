from ..abstract_parts import *
from .JlcPart import JlcPart


class Mcp4728_Device(InternalSubcircuit, FootprintBlock, GeneratorBlock, JlcPart):
  @init_in_parent
  def __init__(self) -> None:
    super().__init__()
    self.vss = self.Port(Ground())
    self.vdd = self.Port(VoltageSink(
      voltage_limits=(2.7, 5.5)*Volt,
      current_draw=(0.040, 1400)*uAmp))  # power down to all channels in normal mode

    out_model = AnalogSource.from_supply(
      self.vss, self.vdd,  # assumed Vref=Vdd, also configurable
      current_limits=(-15, 15)*mAmp,  # short circuit current, typ
      impedance=(1, 1)*Ohm  # DC output impednace in normal mode
    )
    self.vout0 = self.Port(out_model, optional=True)
    self.vout1 = self.Port(out_model, optional=True)
    self.vout2 = self.Port(out_model, optional=True)
    self.vout3 = self.Port(out_model, optional=True)

    dio_model = DigitalBidir.from_supply(
      self.vss, self.vdd,
      voltage_limit_tolerance=(-0.3, 0.3)*Volt,
      input_threshold_factor=(0.3, 0.7)  # for Vdd >= 2.7v
    )
    self.i2c = self.Port(I2cTarget(dio_model, addresses=[0x60]))  # TODO 3LSBs EEPROM programmable
    self.ldac = self.Port(DigitalSink.from_bidir(dio_model), optional=True)
    self.rdy = self.Port(DigitalSingleSource.low_from_supply(self.vss), optional=True)

    self.generator_param(self.ldac.is_connected())

  def generate(self) -> None:
    super().generate()

    if self.get(self.ldac.is_connected()):
      ldac_pin: CircuitPort = self.ldac
    else:
      ldac_pin = self.vdd

    self.footprint(
      'U', 'Package_SO:MSOP-10_3x3mm_P0.5mm',
      {
        '1': self.vdd,
        '2': self.i2c.scl,
        '3': self.i2c.sda,
        '4': ldac_pin,
        '5': self.rdy,  # float if not connected
        '6': self.vout0,
        '7': self.vout1,
        '8': self.vout2,
        '9': self.vout3,
        '10': self.vss,
      },
      mfr='Microchip Technology', part='MCP4728-E/UN',
      datasheet='https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/22187E.pdf'
    )
    self.assign(self.lcsc_part, 'C108207')
    self.assign(self.actual_basic_part, False)


class Mcp4728(DigitalToAnalog, GeneratorBlock):
  """MCP4728 quad 12-bit I2C DAC, with selectable internal or external Vref=Vdd.
  Note, MCP47F seems to be a similar architecture but the example application has an optional
  0.1uF capacitor on the VoutN lines to reduce noise, which is generated by default here.
  """
  @init_in_parent
  def __init__(self, output_caps: BoolLike = True) -> None:
    super().__init__()
    self.ic = self.Block(Mcp4728_Device())
    self.pwr = self.Export(self.ic.vdd, [Power])
    self.gnd = self.Export(self.ic.vss, [Common])

    self.out0 = self.Export(self.ic.vout0, optional=True)
    self.out1 = self.Export(self.ic.vout1, optional=True)
    self.out2 = self.Export(self.ic.vout2, optional=True)
    self.out3 = self.Export(self.ic.vout3, optional=True)

    self.i2c = self.Export(self.ic.i2c)
    self.ldac = self.Export(self.ic.ldac, optional=True)  # can update per-channel by i2c
    self.rdy = self.Export(self.ic.rdy, optional=True)  # can be read from i2c

    self.output_caps = self.ArgParameter(output_caps)
    self.generator_param(self.output_caps, self.out0.is_connected(), self.out1.is_connected(),
                         self.out2.is_connected(), self.out3.is_connected())

  def generate(self) -> None:
    super().generate()

    self.vdd_cap = ElementDict[DecouplingCapacitor]()
    self.vdd_cap[0] = self.Block(DecouplingCapacitor(0.1 * uFarad(tol=0.2))).connected(self.gnd, self.pwr)
    self.vdd_cap[1] = self.Block(DecouplingCapacitor(10 * uFarad(tol=0.2))).connected(self.gnd, self.pwr)

    if self.get(self.output_caps):
      self.out_cap = ElementDict[Capacitor]()
      for i, out_port in [(0, self.out0), (1, self.out1), (2, self.out2), (3, self.out3)]:
        if self.get(out_port.is_connected()):
          self.out_cap[i] = out_cap = self.Block(Capacitor(0.1*uFarad(tol=0.2), out_port.link().voltage))
          self.connect(out_cap.pos.adapt_to(AnalogSink()), out_port)
          self.connect(out_cap.neg.adapt_to(Ground()), self.gnd)
