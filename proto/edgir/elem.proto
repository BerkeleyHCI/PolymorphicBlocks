/**
   File : elem.proto
   Package : edg.elem

   Elements (Blocks, Ports, Links, and Envs) are all equivalent to
   a set of declarations with some typing information, howver it is
   much nicer to parse them out into more concrete structures.

   We don't strictly differentiate between library elements and
   elements within a design within the protobuf. In general, when
   there is a library element, we
 */

syntax = "proto3";
package edgir.elem;
import "edgir/common.proto";
import "edgir/init.proto";
import "edgir/expr.proto";
import "edgir/ref.proto";


message Port {

  map<string, edgir.init.ValInit> params = 10;
  map<string, edgir.expr.ValueExpr> constraints = 11;

  edgir.ref.LibraryPath self_class = 20;
  repeated edgir.ref.LibraryPath superclasses = 21;  // superclasses, may be empty
  // TODO: this provides type hierarchy data only, inheritance semantics are currently undefined

  edgir.common.Metadata meta = 127;
}

message Bundle {
  map<string, edgir.init.ValInit> params = 10;
  map<string, PortLike> ports = 11;
  map<string, edgir.expr.ValueExpr> constraints = 12;

  edgir.ref.LibraryPath self_class = 20;
  repeated edgir.ref.LibraryPath superclasses = 21;  // superclasses, may be empty

  edgir.common.Metadata meta = 127;
}

message PortArray {
  /* The class that applies to every port in the set/array. Used
     when a new port is instantiated by the front or back end. */
  edgir.ref.LibraryPath self_class = 20;

  /* Only designs should contain actual ports here */
  map<string, PortLike> ports = 13;

  edgir.common.Metadata meta = 127;
}

/** Wrapper for different port like elements */
message PortLike {
  oneof is {
    edgir.common.Empty undefined = 1;
    edgir.ref.LibraryPath lib_elem = 2;
    /** 'port' disallowed w/in the library */
    Port       port   = 3;
    PortArray  array  = 4;
    /** 'bundle' disallowed w/in the library */
    Bundle     bundle = 6;
  }
}

message HierarchyBlock {
  map<string, edgir.init.ValInit>   params = 10;
  // Refinements may introduce new parameters which would not be assigned a value in the parent class.
  // In those cases, those new parameters are given these default values.
  map<string, edgir.expr.ValueExpr> param_defaults = 15;
  map<string, PortLike>          ports  = 11;
  /** Bridges, which adapt an edge port to a link port - eg, edge VoltageSink to an internal link
      VoltageSource, are defined as blocks in the IR. Upper layers can define convenience constructs and/or
      infer these blocks. */
  map<string, BlockLike>          blocks = 12;
  map<string, LinkLike>           links  = 13;
  /** Connections between internal block and link ports are represented by connected constraints.
      Connections between internal; block and edge (of this block) ports are represented by exported constraints. */
  map<string, edgir.expr.ValueExpr> constraints = 14;

  edgir.ref.LibraryPath self_class = 23;  // self class, equivalent to the library name
  repeated edgir.ref.LibraryPath superclasses = 20;  // superclasses, may be empty
  edgir.ref.LibraryPath prerefine_class = 21;  // if refined: the class pre-refinement; otherwise equal to class
  map<string, Generator> generators = 22;  // optional, and removed upon invocation

  bool is_abstract = 30;  // true if self_class is abstract, and should error if used in a design

  edgir.common.Metadata meta = 127;
}

message Generator {
  string fn = 1;  // Python function name for the generator. TODO dupe of the key in the containing map?

  // Parameters that must be defined for the generator to fire.
  // These parameters are the only ones accessible to the generator.
  // TODO: perhaps should be a more general ValueExpr?
  repeated edgir.ref.LocalPath required_params = 2;

  // Ports that must have defined connected-ness for the generator to fire.
  // This makes the port's IS_CONNECTED and CONNECTED_LINK.NAME available.
  repeated edgir.ref.LocalPath required_ports = 3;

  // Internal blocks that this generator can (but not necessarily) make connections to.
  // TODO generalize to include all ports to allow appending connections?
  repeated edgir.ref.LocalPath connected_blocks = 4;

  // TODO: how to allow multiple generators based on different input combinations?
  // Perhaps a way for generators to obliviate one another?
}

message BlockLike {
  oneof type {
    edgir.common.Empty undefined = 1;
    edgir.ref.LibraryPath lib_elem = 2;
    /** not allowed w/in the library */
    HierarchyBlock hierarchy = 4;
  }
}

message Link {

  map<string, edgir.init.ValInit> params = 10;
  map<string, PortLike>          ports  = 11;
  map<string, LinkLike>           links  = 13;
  map<string, edgir.expr.ValueExpr> constraints = 12;

  edgir.ref.LibraryPath self_class = 20;
  repeated edgir.ref.LibraryPath superclasses = 21;  // superclasses, may be empty
  // TODO: this provides type hierarchy data only, inheritance semantics are currently undefined

  edgir.common.Metadata meta = 127;
}

message LinkArray {
  /* The class that applies to every link in the set/array. Used
     when a new link is instantiated by the front or back end. */
  edgir.ref.LibraryPath self_class = 20;

  /* Only designs should contain an implementation here */
  map<string, PortLike>          ports  = 11;  // the last index is the index of the link, the first indices (if any) are the indices of the corresponding port in the inner link
  map<string, edgir.expr.ValueExpr> constraints = 12;  // includes all exported constraints to map link ports to my ports
  map<string, LinkLike> links = 13;

  edgir.common.Metadata meta = 127;
}

message LinkLike {
  oneof type {
    edgir.common.Empty undefined = 1;

    edgir.ref.LibraryPath lib_elem = 2;

    /** not allowed w/in the library */
    Link link = 3;
    LinkArray array = 4;
  }
}
